[{"title":"关于CSS属性float","date":"2020-02-10T12:24:27.000Z","path":"articles/css-float/","text":"float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内敛元素环绕它。该元素从网页的正常流动（文档流）中移除，尽管任然保持部分的流动性。 基本用法float: none | left | right | inline-start | inline-end 属性值 含义 none 表明元素不进行浮动 left 表明元素必须浮动在其所在的块容器左侧 right 表明元素必须浮动在其所在的块容器右侧 inline-start 明元素必须浮动在其所在块容器的开始一侧，在ltr脚本中是左侧，在rtl脚本中是右侧 inline-end 表明元素必须浮动在其所在块容器的结束一侧，在ltr脚本中是右侧，在rtl脚本中是左侧 下图为浏览器对float和对float属性值的支持情况： 浏览器对float和对float属性值的支持情况 浮动元素定义浮动元素是指float 属性的计算值非 none 的元素。 如何定位当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素 浮动产生的副作用 块状元素会被浮动元素覆盖, 如图： 块状元素被浮动元素覆盖 行内元素，例如文字，会环绕在浮动元素周围，为浮动元素留出空间，如图 行内元素环绕在浮动元素周围，为浮动元素留出空间 浮动元素父元素塌缩，如图： 浮动元素父元素塌缩 如何清除浮动下面假设一个应用场景：一个无序列表ol，里面的列表项li自动按序排列且个数不确定，ul需要一个背景:理想情况应该是这样的： 应用场景理想情况表现 但是如果使用了浮动就会出现下面这种情况： 应用场景使用浮动表现 这种情况的代码如下（所有li标签使用了 float: left）：12345678910111213141516&lt;ul style=&quot;width: 100%; background: hsl(360, 50%, 50%)&quot;&gt; &lt;li style=&quot;width: 33%; float: left; background: hsl(240, 50%, 50%);&quot;&gt; item1 &lt;/li&gt; &lt;li style=&quot;width: 33%; float: left; background: hsl(240, 50%, 50%);&quot;&gt; item2 &lt;/li&gt; &lt;li style=&quot;width: 33%; float: left; background: hsl(240, 50%, 50%);&quot;&gt; item3 &lt;/li&gt; &lt;li style=&quot;width: 33%; float: left; background: hsl(240, 50%, 50%);margin-right: 1%;&quot; &gt; item4 &lt;/li&gt;&lt;/ul&gt; 我们发现，使用浮动以后并没有达到我们想要的结果，事实上，ul元素的高度为0，也就是出现了元素塌缩的情况，这就是li元素使用了浮动造成的结果。为了达到我们需要的理想效果，我们需要清除浮动，那么如何清除呢？ 添加空元素在浮动元素下方添加一个非浮动元素，也就是在15行和16行代码之间插一句:&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt; 原理：容器现在必须考虑非浮动子元素的位置，而后者肯定出现在浮动元素下方，所以显示出来，父容器就把所有子元素都包括进去了。缺点：在页面中增加冗余标签，违背了语义化的原则。 浮动的父容器将父元素容器也改成浮动元素，这样它就可以带着子元素一起浮动了，将第一行的代码：&lt;ul style=&quot;width: 100%; background: hsl(360, 50%, 50%)&quot;&gt; 改成（加上 float:left ）：&lt;ul style=&quot;float:left; width: 100%; background: hsl(360, 50%, 50%)&quot;&gt; 缺点：这样虽然解决了当前的这个问题，但是这样父容器ul又变成了浮动元素，可能会影响到后面的元素，而且有时候，父容器是定位死的，无法变成浮动。不推荐使用这种方法 父元素加上 overflow: hidden 样式将第一行的代码：&lt;ul style=&quot;width: 100%; background: hsl(360, 50%, 50%)&quot;&gt; 改成（加上 overflow: hidden ）：&lt;ul style=&quot;overflow: hidden; width: 100%; background: hsl(360, 50%, 50%)&quot;&gt; 缺点：一个是IE6不支持，另一个是一旦子元素的大小超过父容器的大小，就会出显示问题。 父元素添加 :after 伪元素在样式表中添加以下样式类： .clearfix::after { content: &quot; &quot;; /* 内容设置为空白字符 */ display: block; /* 确保这个空白字符是非浮动的独立区块 */ clear: both; /* 确保这个空白字符是非浮动的独立区块 */ height: 0; /* 不让空白字符显示出来 */ } .clearfix { zoom: 1; /* 不支持IE6 ::after 属性，这条属性可以激活父元素的&quot;hasLayout&quot;属性，使得能够兼容IE6 */ } 然后将第一行的代码： &lt;ul style=&quot;width: 100%; background: hsl(360, 50%, 50%)&quot;&gt; 改成（加上 clearfix 类）： &lt;ul class=&quot;clearfix&quot; style=&quot;width: 100%; background: hsl(360, 50%, 50%)&quot;&gt; 这是目前最为流行、最推荐的方法Nicolas Gallagher 贴出了更通用的生产代码： .cf:before, .cf:after { content: &quot; &quot;; display: table; } .cf:after { clear: both; } /** * For IE 6/7 only * Include this rule to trigger hasLayout and contain floats. */ .cf { *zoom: 1; }","categories":[{"name":"前端","slug":"前端","permalink":"https://eviler.top/categories/前端/"}],"tags":[{"name":"CSS/CSS3","slug":"CSS-CSS3","permalink":"https://eviler.top/tags/CSS-CSS3/"}]},{"title":"进程与线程","date":"2020-02-10T09:14:32.000Z","path":"articles/process-and-thread/","text":"进程（process）和线程（thread）是操作系统中的两个基本概念，但是这两个的概念有些抽象，所以这里用类比的方法介绍一下这两个的概念，方便理解。 类比假设有一个工厂，工厂里面有许多车间，每个车间里有许多工人，所有车间的工作都必须用电。我们将用工厂和计算机做一个类比来解释进程和线程。 CPU是计算机的核心，计算机内的所有计算任务都是由它来完成的。我们将电力类比为CPU（虽然这样类别不太准确，但突出了没有CPU计算机就无法工作特征，有这个就够了，如果没有CPU，计算机将无法工作，同样没有电力，整个工厂也就无法开工了）。 假定工厂的电力有限，一次只能供一个车间使用，也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行任务进程就好比工厂里面的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 一个车间里，可以有很多工人。他们协同完成一个任务。线程就好比车间里的工人，一个进程可以包括多个线程。 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。 不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 操作系统的设计，可以归结为三点： 以多进程形式，允许多个任务同时运行； 以多线程形式，允许单个任务分成不同的部分运行； 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。 引用进程与线程的一个简单解释","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://eviler.top/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://eviler.top/tags/操作系统/"}]}]