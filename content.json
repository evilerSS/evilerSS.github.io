[{"title":"Web安全——浏览器安全","date":"2019-11-04T01:36:52.000Z","path":"articles/web-security-browser/","text":"浏览器发展大到今天已经成为绝大多数用户使用得联网工具，浏览器市场的竞争也日趋白热化，浏览器安全也在这种环境中被越来越多人重视，许多浏览器厂商也在这方面下足了功夫。今天我看了一下关于浏览器安全的一些知识，并且把重点部分记录了下来。在讲浏览器安全之前先讲一讲安全三要素与四个安全原则。 安全三要素与四个安全原则安全三要素 机密性(Confidentiality)：要求保护数据内容不能泄露，加密是实现机密性的常见手段。 完整性(Integrity)：要求保护数据内容是完整、没有被篡改的。常见的保证一致性的手段是数字签名。 可用性(Availability)：要求保护资源是”随需而得”。有一种攻击叫做拒绝服务攻击，简称DoS(Defial of Service)，DoS就是破坏安全的可用性。 还有一些诸如可审计性、不可抵赖性等，但最重要的是以上三个要素。 四个安全原则 Secure By Default原则 黑名单、白名单：一般情况下我们使用白名单的方式来保证安全，如服务器端口开放、富文本html标签、跨域访问策略文件。 最小权限原则：要求系统只授予主体必要的权限，而不要过渡授权，这样能有效减少系统、网络、应用、数据库出错的机会。 纵深防御原则：包括两层含义，首先，要在各个不同层面、不同方面实施安全方案，避免出现疏漏，不同安全方案之间需要相互配合，构成一个整体；其次，要在正确的地方做正确的事情，即：在解决根本问题的地方实施针对性的安全方案。 数据与代码分离原则：这一原则广泛使用于各种由于“注入”而引发安全问题的场景。实际上，缓冲区溢出也可以认为是程序违背了这一原则的后果——程序在栈或者队中，将用户数据当作代码执行，混淆了代码与数据的边界，从而导致安全问题的发生。在Web安全中，由“注入”引起的问题如XSS、SQL Injection、CRLF Injection、X-Path Injection等。此类问题均可以根据“数据与代码分离原则”设计出真正安全的解决方案，因为这个原则抓住了漏洞形成的本质原因。 不可预测性原则：能够有效对抗基于篡改、伪造的攻击。比如数据表里面的id字段，如果是可预测的，那么攻击者要想批量删除这些数据，直接写个简单的循环删除的脚本就可以了；还有token等。不可预测性的实现往往需要用到加密算法、随机数算法、哈希算法。 浏览器安全同源策略同源策略(Same Origin Policy)是一种约定，它是浏览器最核心也是最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能会受到影响。可以说Web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。浏览器的同源策略，限制了来自不同源的 “document” 或脚本，对当前 “document” 读取或设置某些属性。这一策略极其重要。影响“源”的因素有：host(域名或IP地址)、子域名、端口、协议。对于当前页面来说，页面内存放Javascript文件的域并不重要，重要的是加载Javascript页面所在的域是什么，换言之，a.com通过以下代码： &lt;script src=&quot;http://b.com/b.js&quot;&gt;&lt;/script&gt; 加载了b.com上的b.js，但是b.js是运行在a.com页面中的，因此对于当前打开的页面(a.com页面)来说，b.js的Origin就应该是a.com而非b.com。在浏览器中&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;等标签都可以跨域加载资源，而不受同源策略的限制。这些带“src”属性的标签每次加载时，实际上是由浏览器发起了一次GET请求。不同于XMLHttpResuest的是，通过src属性加载的资源，浏览器限制了Javascript的权限，使其不能读、写返回的内容。XMLHttpRequest受到同源策略的约束，不能跨域访问资源，如果XMLHttpRequest能够跨域访问资源，则可能会导致一些敏感数据泄露，比如CSRF的token，从而导致发生安全问题。但是随着业务的发展，跨域请求的需求越来越迫切，因此W3C委员会制定了XMLHttpRequest跨域访问标准。它需要通过目标域返回的HTTP头来授权是否允许跨域访问，因为HTTP头对于Javascript爱说一般是无法控制的，所以认为这个方案可以实施。注意：这个跨域访问方案的安全基础就是信任“Javascript无法控制该HTTP头”，如果此信任基础被打破，此方案也将不再安全。对于浏览器来说，除了DOM、Cookie、XMLHttpRequest会受到同源策略的限制外，浏览器加载的一些第三方插件也有各自的同源策略。最常见的一些插件如Flash、Java Applet、Silverlight、Google Gears等都有自己的控制策略。 浏览器沙箱在网页中插入一段恶意代码，历以浏览器漏洞执行任意代码的攻击方式，在黑客圈子里被形象地成为“挂马”。为了对抗挂马，浏览器厂商根据挂马特点研究出了一些对抗挂马的技术，浏览器还发展出了多进程架构。浏览器的多进程架构，将浏览器的各个功能模块分开，各个浏览器实例分开，当一个进程奔溃时，也不会影响其他的进程。Google Chrome是第一个采取多进程架构的浏览器。Google Chrome的主要进程为：浏览器进程、渲染进程、插件进程、扩展进程。插件进程如flash、java、pdf等与浏览器进程严格隔离，因此不会相互影响。渲染引擎由Sandbox隔离，网页代码要与浏览器内核进行通信、与操作系统通信都需要通过IPC channel，在其中会进行一些安全检查。在现今的浏览器中，虽然由多进程架构和Sandbox的保护，但是浏览器所加载的一些三方插件却往往不受Sandbox管辖。 恶意网址拦截钓鱼网站、诈骗网站对于用户来说是一种恶意网址。为了保护用户安全，浏览器厂商纷纷推出了各自的拦截恶意网址功能。目前各个浏览器的拦截恶意网址的功能都是基于“黑名单”的。恶意网址拦截的原理很简单，一般都是浏览器周期性地从服务器端获取一份最新的恶意网址黑名单，如果用户上网时访问的网址存在于此黑名单中，浏览器会弹出一个警告页面。常见的恶意网址分为两类：一类是挂马网站，这些网站通常包含由恶意的脚本如Javascript或Flash，通过利用浏览器的漏洞（包括一些插件、控件漏洞）执行shellcode，在用户电脑中植入木马；另一类是钓鱼网站，通过模仿知名网站的相似页面来欺骗用户。PhishTank是互联网上免费提供恶意网站黑名单的组织之一，它的黑名单由世界各地的志愿者提供，且更新频繁。除了恶意网站黑名单功能为，主流浏览器都开始支持EVSSL证书(Extened Validation SSL Certificate)，以增强对安全网站的识别。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://eviler.top/tags/Web安全/"},{"name":"浏览器","slug":"浏览器","permalink":"https://eviler.top/tags/浏览器/"}]},{"title":"Javascript中的正则表达式详解以及一些常用表单验证实例","date":"2018-11-28T12:06:49.000Z","path":"articles/javascript-regexp/","text":"正则表达式是一个非常好用并且经常会用到的工具，然而学习了好长时间javascript却没有好好地学习一下正则表达式，现在系统地学习一下，并且学以致用，自己写几个用于表单数据格式验证的实例。 什么是正则表达式正则表达式（英语：Regular Expression，再代码证常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 正则表达式是有一个字符序列形成的搜索模式。 当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。 正则表达式可以是一个简单的字符，或一个更复杂的模式。 正则表达式可用于所有文本搜索和文本替换的操作。 语法var patt = new Reg(pattern, modifiers); 或者更简单的方式： var patt=/pattern/modifiers pattern(模式)描述了表达式的模式 modifiers(修饰符)用于指定全局匹配、区分大小写的匹配和多行匹配注意:当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。比如，以下是等价的： var re = new RegExp(“\\w+”); var re = /\\w+/;RegExp修饰符修饰符用于执行不区分大小写和全文的搜索。 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配 RegExp模式方括号方括号用于查找某个范围的字符： 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 ( red &#124; blue &#124; green ) 查找任何指定的选项。 元字符元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \\w 查找单词字符。 \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NULL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 什么是单词边界？找到一个博客，上面有讲解：正则表达式单词边界和非单词边界 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 例如，/a+/ 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。 n* 匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。 n? 匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 “angel” 中的 “el”，”angle” 中的 “le”。 n{X} 匹配包含 X 个 n 的序列的字符串。例如，/a{2}/ 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。 n{X,} X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a{2,}/ 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。 n{X,Y} X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。 例如，/a{1,3}/ 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。捕获性分组 ?:n 匹配任何其后紧接指定字符串 n 的字符串。非捕获性分组 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 捕获性分组，非捕获性分组，前瞻，后瞻 RegExp 对象方法test方法检索字符串中指定的值。返回 true 或 false。语法：RegExpObject.test(string)参数：string：必须。要检测的字符串。实例： var str=&quot;Hello world!&quot;; //查找&quot;Hello&quot; var patt=/Hello/g; var result=patt.test(str); document.write(&quot;返回值: &quot; + result); //查找 &quot;Runoob&quot; patt=/Runoob/g; result=patt.test(str); document.write(&quot;&lt;br&gt;返回值: &quot; + result); 实例输出结果： 返回值: true 返回值: false exec方法用于检索字符串中的正则表达式的匹配，如果字符串中有匹配的值返回该匹配值，否则返回 null。语法：RegExpObject.exec(string)参数：string：必须。要检测的字符串。实例： var str=&quot;Hello world!&quot;; //查找&quot;Hello&quot; var patt=/Hello/g; var result=patt.exec(str); document.write(&quot;返回值: &quot; + result); //查找 &quot;RUNOOB&quot; patt=/RUNOOB/g; result=patt.exec(str); document.write(&quot;&lt;br&gt;返回值: &quot; + result); 实例输出结果： 返回值: Hello 返回值: false 说明：exec() 方法的功能非常强大，它是一个通用的方法，而且使用起来也比 test() 方法以及支持正则表达式的 String 对象的方法更为复杂。如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。比如以下的实例： var str = &quot;Visit W3School&quot;; var patt = new RegExp(&quot;W3School&quot;,&quot;g&quot;); var result; while ((result = patt.exec(str)) != null) { document.write(result); document.write(&quot;&lt;br /&gt;&quot;); document.write(patt.lastIndex); } 输出： W3School 14 compile方法compile() 方法用于在脚本执行过程中编译正则表达式。compile() 方法也可用于改变和重新编译正则表达式。语法：RegExpObject.compile(regexp,modifier)参数：regexp：正则表达式；modifier：规定匹配的类型实例：在字符串中全局搜索 “man”，并用 “person” 替换。然后通过 compile() 方法，改变正则表达式，用 “person” 替换 “man” 或 “woman” var str=&quot;Every man in the world! Every woman on earth!&quot;; patt=/man/g; str2=str.replace(patt,&quot;person&quot;); document.write(str2+&quot;&lt;br /&gt;&quot;); patt=/(wo)?man/g; patt.compile(patt); str2=str.replace(patt,&quot;person&quot;); document.write(str2); 实例输出： Every person in the world! Every woperson on earth! Every person in the world! Every person on earth! toString方法返回正则表达式的字符串值语法：RegExpObject.toString()实例： var patt = new RegExp(&quot;Eviler&quot;, &quot;g&quot;); var res = patt.toString(); document.weite(res); 实例输出： /Eviler/g RegExp 对象属性 属性 描述 global 判断是否设置了 “g” 修饰符 ignoreCase 判断是否设置了 “i” 修饰符 multiline 判断是否设置了 “m” 修饰符 constructor 返回一个函数，该函数是一个创建 RegExp 对象的原型。 lastIndex 用于规定下次匹配的起始位置 source 返回正则表达式的匹配模式 注意： lastIndex 属性只有设置标志 g 才能使用。上次匹配的结果是由方法 RegExp.exec() 和 RegExp.test() 找到的，它们都以 lastIndex 属性所指的位置作为下次检索的起始点。这样，就可以通过反复调用这两个方法来遍历一个字符串中的所有匹配文本。 该属性是可读可写的。只要目标字符串的下一次搜索开始，就可以对它进行设置。当方法 exec() 或 test() 再也找不到可以匹配的文本时，它们会自动把 lastIndex 属性重置为 0。 支持正则表达式的String对象的方法search方法search方法用来检索与正则表达式相匹配的值实例：查找”Eviler”: var str=&quot;Visit Eviler&apos;s Blog!&quot;; var n=str.search(&quot;Eviler&quot;); document.write(n); 实例输出： 6 match方法match方法用来找到一个或多个正则表达式的匹配实例： var str=&quot;The rain in SPAIN stays mainly in the plain&quot;; var n=str.match(/ain/g); document.write(n); 实例输出： ain,ain,ain 注意：match() 方法将检索字符串 String Object，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。 replace方法replace方法用来替换与正则表达式匹配的子串实例： var str=&quot;There are some men and women!Men and Women!&quot;; document.write(&quot;原字符串：&quot;+ &quot;&lt;br /&gt;&quot;+str+ &quot;&lt;br /&gt;&quot;); var m=str.replace(/men/i,&quot;boys&quot;); document.write(&quot;将第一个&apos;men&apos;(不区分大小写)替换成&apos;boys&apos;：&quot;+ &quot;&lt;br /&gt;&quot;+m + &quot;&lt;br /&gt;&quot;); var n=str.replace(/women/gi,&quot;girls&quot;); document.write(&quot;将所有&apos;women&apos;(不区分大小写)替换成&apos;girls&apos;：&quot;+ &quot;&lt;br /&gt;&quot;+n); 实例输出： 原字符串： There are some men and women!Men and Women! 将第一个&apos;men&apos;(不区分大小写)替换成&apos;boys&apos;： There are some boys and women!Men and Women! 将所有&apos;women&apos;(不区分大小写)替换成&apos;girls&apos;： There are some men and girls!Men and girls! split方法split方法用来把字符串分割为字符串数组实例：获取一段英文句子中的单词 var str=&quot;This is my personal page&quot;; document.write(str.split(&apos; &apos;)); 实例输出： This,is,my,personal,page 综合实例&amp;常用表单数据格式验证代码//验证是否位合法的邮箱地址 function isEmail(str) { var reg = /^\\w+@[a-zA-Z0-9]{2,10}(?:\\.[a-z]{2,4}){1,3}$/; return reg.test(str); } //验证是否是合法的手机号码 function isPhoneNumber(str) { var reg = /^1[34578]\\d{9}$/; return reg.test(str); } //验证中国邮政编码,开头不能为0，共6位 function isZipCode(str) { var reg = /^[1-9]\\d{5}$/; return reg.test(str); } //验证中文姓名，2-5个汉字 function isChainName(str) { var reg = /^[\\u4E00-\\u9FA5]{2,5}$/; return reg.test(str); } //验证是否为正整数 function isNumber(str) { if (!str) { return false; } var reg = /\\D/; return !reg.test(str); } 试一试邮&#12288;&#12288;箱：手机号码：邮政编码：中文姓名：正整数验证：验证 function submit() { var input1 = document.getElementById(\"input1\"); var value1 = input1.value; input1.parentNode.querySelector(\".warning\").innerHTML = isEmail(value1) var input2 = document.getElementById(\"input2\"); var value2 = input2.value; input2.parentNode.querySelector(\".warning\").innerHTML = isPhoneNumber(value2) var input3 = document.getElementById(\"input3\"); var value3 = input3.value; input3.parentNode.querySelector(\".warning\").innerHTML = isZipCode(value3) var input4 = document.getElementById(\"input4\"); var value4 = input4.value; input4.parentNode.querySelector(\".warning\").innerHTML = isChainName(value4) var input5 = document.getElementById(\"input5\"); var value5 = input5.value; input5.parentNode.querySelector(\".warning\").innerHTML = isNumber(value5) } //验证是否位合法的邮箱地址 function isEmail(str) { var reg = /^\\w+@[a-zA-Z0-9]{2,10}(?:\\.[a-z]{2,4}){1,3}$/; return reg.test(str); } //验证是否是合法的手机号码 function isPhoneNumber(str) { var reg = /^1[34578]\\d{9}$/; return reg.test(str); } //验证中国邮政编码,开头不能为0，共6位 function isZipCode(str) { var reg = /^[1-9]\\d{5}$/; return reg.test(str); } //验证中文姓名，2-5个汉字 function isChainName(str) { var reg = /^[\\u4E00-\\u9FA5]{2,5}$/; return reg.test(str); } //验证是否为正整数 function isNumber(str) { if (!str) { return false; } var reg = /\\D/; return !reg.test(str); }","tags":[{"name":"javascript","slug":"javascript","permalink":"https://eviler.top/tags/javascript/"}]}]