[{"title":"面向对象的程序设计","date":"2019-04-23T10:56:35.000Z","path":"articles/javascript-object-oriented-programming/","text":"面向对象(Object-Oriented,OO)的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象，比如java和c++。但是ECMAScript中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。 理解对象定义ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”也就是说，对象是一组没有特定顺序的名对值。对象的每个属性或方法都有一个名字，而每个名字都隐射到一个值（数据或者函数）。每个对象都是基于一个引用类型创建的。创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它 添加属性和方法： var person = new Object(); person.name = &quot;Eviler&quot;; person.age = 22; person.sayName = function(){ alert(this.name); } 对象字面量模式创建： var person = { name: &quot;Eviler&quot;, age: 22, sayName: function(){ alert(this.name); } } 属性类型ECMA-262第五版在定义只有内部才用的特征(attribute)时，描述了属性(property)的各种特征。这些特征是为了实现javascript引擎用的，因此在JavaScript中不能直接访问它们。ESCAScript有两种属性:数据属性和访问器属性 数据属性configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。对于直接在对象上定义的属性，默认值为true。enumerable：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，默认值为true。writable：表示能够修改属性的值。对于直接在对象上定义的属性，默认值为true。value：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为undefined。要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接受三个参数：属性所在的对象、属性的名字和一个描述符的对象。其中描述符对象的属性必须是：configurable、enumerable、wriable和value中的一个或者多个。例如： var person = {}; Object.defineProperty(person, &quot;name&quot;, { writable: false, value: &quot;Eviler&quot; }), console.log(person.name); //Eviler person.name = &quot;Hello&quot;; console.log(person.name); //Eviler person.name 的赋值语句在非严格模式下会被忽略，但在严格模式下，赋值操作将会导致抛出错误:TypeError: Cannot assign to read only property ‘name’ of object ‘#&lt;Object>‘。 同样，对于下面的语句： var person = {}; Object.defineProperty(person, &quot;name&quot;, { configurable: false, value: &quot;Eviler&quot; }); console.log(person.name); //Eviler delete person.name; //非严格：忽略； 严格：TypeError: Cannot delete property &apos;name&apos; of #&lt;Object&gt; Object.defineProperty(person, &quot;name&quot;, { configurable: false, value: &quot;Eviler2&quot; }); //不管是非严格还是严格模式都会报错：TypeError: Cannot redefine property: name 特别注意：在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特征的默认值都是false。 &quot;use strict&quot;//严格模式下 var person = {}; Object.defineProperty(person, &quot;name&quot;, { value: &quot;Eviler&quot; }); console.log(person.name); //Eviler delete person.name; //TypeError: Cannot delete property &apos;name&apos; of #&lt;Object&gt; person.name = &quot;Hello&quot;; //TypeError: Cannot assign to read only property &apos;name&apos; of object &apos;#&lt;Object&gt;&apos; for (var key in person) { console.log(key + &quot;: &quot; + person[key]); } //只会打印可枚举的熟悉 访问器属性访问器属性不包含数据值；它们包含一对getter和setter函数（都不是必需的）。在读取访问器属性时，会调用getter函数，返回有效的值；在写入属性访问器时，会调用setter函数并传入新值，这个函数负责决定图个处理数据。访问器属性有如下4个特征：configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。对于直接在对象上定义的属性，默认值为true。enumerable：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，默认值为true。get：在读取属性时调用的函数。默认值为undefined。set：在写入属性时调用的函数。默认值为undefined。访问器属性不能直接定义，必须使用Object.defineProperty()方法 &quot;use strict&quot; var book = { _year: 2018, edition: 1 } Object.defineProperty(book, &quot;year&quot;, { get: function () { console.log(&quot;getter&quot;); return this._year; }, set: function (newValue) { console.log(&quot;setter&quot;); if (newValue &gt; 2018) { this._year = newValue; this.edition += newValue - 2018; } } }) console.log(book.edition); console.log(book.year); book.year = 2019; console.log(book.edition); console.log(book.year); // 打印结果： 1 &quot;getter&quot; 2018 &quot;setter&quot; 2 &quot;getter&quot; 2019 javascript中不存在私有属性的概念，所有属性都是公开的。为了表示私有变量，我们用_year表示，表示它只能通过对象方法访问不一样非要指定getter和setter，只指定getter意味着属性不能写，尝试写入属性会被忽略，严格模式下，会抛出错误。类似地，没有指定setter函数的属性也不能读，否则在非严格模式写会返回undefined，而在严格模式下会抛出错误。浏览器支持：IE 9+(IE8知识部分实现)、Firefox 4+、Safari 5+、Opera 12+和Chrome。在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：defineGetter()和defineSetter()。熟悉Vue.js的人应该知道，Vue不支持IE8及以下版本，因为Vue使用了IE8无法模拟的ECMAScript 5特性，其中就包括Object.defineProperty()这个函数，其实vue中数据的双向绑定就是使用这个特性实现的。 定义多个属性使用ECMAScript 5的Object.defineProperties()函数，这个函数接受两个对象参数，第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应，如： &quot;use strict&quot; var book = {}; Object.defineProperties(book, { _year: { writable: true, value: 2018 }, edition: { writable: true, value: 1 }, year: { get: function () { return this._year; }, set: function (newValue) { if (newValue &gt; 2018) { this._year = newValue; this.edition += newValue - 2018; } } } }) console.log(book.year); book.year = 2019; console.log(book.year); 浏览器支持：IE 9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。 读取属性的特征使用ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接受两个参数：属性所在的对象和要读物其描述符的属性名称，返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value，例如： &quot;use strict&quot; var book = {}; Object.defineProperties(book, { _year: { writable: true, value: 2018 }, edition: { writable: true, value: 1 }, year: { get: function () { return this._year; }, set: function (newValue) { if (newValue &gt; 2018) { this._year = newValue; this.edition += newValue - 2018; } } } }) console.log(Object.getOwnPropertyDescriptor(book, &quot;edition&quot;)); console.log(Object.getOwnPropertyDescriptor(book, &quot;year&quot;)); /* 打印结果： { value: 1, writable: true, enumerable: false, configurable: false } { get: [Function: get], set: [Function: set], enumerable: false, configurable: false } */ 创建对象虽然Object构造函数或对象字面量都可以用来创建单个对象，但是这两种方式有一个明显的缺点：使用同一个接口创建创建很多对象，会产生大量的重复代码。为了解决这个问题，人们开始使用工程模式的一种变体。 工程模式这种模式抽象了创建具体对象的过程，由于ECMAScript无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，例如: function createPerson(name, age) { var o = new Object(); o.name = name; o.age = age; o.sayName = function () { console.log(this.name); } return o; } var p1 = createPerson(&quot;Eviler&quot;, 22); var p2 = createPerson(&quot;Hello&quot;, 18); p1.sayName(); //Eviler p2.sayName(); //Hello createPerson()能够根据接受的参数来和构建一个包含所有信息的Person对象。可以无数地调用这个函数，而每次它都返回一个包含两个属性一个方法的对象。工程模式虽然解决了创建多个相似对象的文尼提，但却没有解决对象识别的问题（即怎样知道一个对象的类型，如下，对上面的p1使用instanceof运算符检测结果）。 console.log(p1 instanceof createPerson);//false console.log(p1 instanceof Object);//true 构造函数模式使用构造函数模式对前面的例子重写 function Person(name, age) { this.name = name; this.age = age; this.sayName = function () { console.log(this.name); } } var p1 = new Person(&quot;Eviler&quot;, 22); var p2 = new Person(&quot;Hello&quot;, 18); p1.sayName(); //Eviler p2.sayName(); //Hello 要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际会经历以下4个步骤: 创建一个新对象； 将构造函数的作用域赋值给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 p1和p2分别保存着Person的一个不同的实例，这两个对象都有一个constructor(构造函数)属性，该属性指向Person，如下所示： console.log(p1.constructor == Person); //true console.log(p1.constructor == Person); //true 对象的constructor属性最初是用来表示对象类型的。但是，instanceof操作符来检测对象类型更可靠一些，对上面的p1使用instanceof运算符检测结果： console.log(p1 instanceof createPerson);//true console.log(p1 instanceof Object);//true//所有对象均继承自Object，所以结果为true 把构造函数当作函数构造函数与其他函数的唯一区别，就在于调用它们的方式不同。任何函数，只要通过new 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。例如，对于前面的Person的构造函数： // 当构造函数使用 var p1 = new Person(&quot;Eviler&quot;, 22); p1.sayName(); //Eviler // 作为普通函数使用(this会被指向global对象，在浏览器中即window对象; 在nodejs中即global对象) Person(&quot;Global&quot;, 15); console.log(window.name);//Global // 在另一个对象的作用域中调用 var o = new Object(); Person.call(o, &quot;OtherObject&quot;, 20); o.sayName(); //OtherObject 构造函数的问题构造函数模式对然好用，但是存在一个主要问题，就是每个方法都要在每个实例上重写创建一遍。在前面的例子中，p1和p2都有一个名为sayName()的方法，但是那两个方法不是同一个Function的实例（ECMAScript中的函数时对象），因此每定义一个函数，也就实例化了一个对象，对内存造成了一定的浪费。况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外面来解决这个问题： var sayName = function () { console.log(this.name); } function Person(name, age) { this.name = name; this.age = age; this.sayName = sayName; } var p1 = new Person(&quot;Eviler&quot;, 22); p1.sayName(); //Eviler 虽然这样解决了重复定义函数的问题，但是又出现了新的问题：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域优点名副其实。而更仍然无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，这写问题可以通过使用原型模式来解决。 原型模式我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是以通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法，如下： function Person() {} console.log(Person.prototype); // Person(){} Person.prototype.name = &quot;Eviler&quot;; Person.prototype.age = 22; Person.prototype.sayName = function () { console.log(this.name); } console.log(Person.prototype); //Person { name: &apos;Eviler&apos;, age: 22, sayName: [Function] } var p1 = new Person(); var p2 = new Person(); p1.sayName(); //Eviler p2.sayName(); //Eviler console.log(p1.sayName == p2.sayName); //true 我们将sayName()方法和所有属性直接添加到了Person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过构造函数来创建对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说p1和p2访问的都是同一组属性和同一个sayName()函数。我们先来看看ECMAScript原型对象的性质 理解原型对象无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象，默认情况下，所有原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针。例如: function Person() {} Person.prototype.name = &quot;Nicholas&quot; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function () { console.log(this.name); } var person1 = new Person(); var person2 = new Person(); 对象Person、Person.prototype、person1和person2的关系如下图所示： 对象关系图 可以看出，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例—-person1和person2都包含一个内部属性，该属性仅仅指向了Person.prototype; 换句话说，它们与构造函数没有直接关系。虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。在所有实现中都无法直接访问[[Prototype]]属性,但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系： console.log(Person.prototype.isPrototypeOf(person1)); //true console.log(Person.prototype.isPrototypeOf(person2)); //true 还可以通过ECMAScript5新增的Object.getPrototypeOf()方法取得实例的原型： console.log(Object.getPrototypeOf(person1)); /*打印结果 Person { name: &apos;Nicholas&apos;, age: 29, job: &apos;Software Engineer&apos;, sayName: [Function] } */ console.log(Object.getPrototypeOf(person2) === Person.prototype); //true 查找对象属性的过程: 搜索首先从对象实例本身开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。事实上，person1调用的sayName()函数是第二次搜索的结果：第一次在实例本身中没有找到，第二次在原型中找到，看如下示例： function Person() {} Person.prototype.name = &quot;Nicholas&quot; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function () { console.log(this.name); } var person1 = new Person(); var person2 = new Person(); person1.name = &quot;Eviler&quot;; person1.sayName(); //Eviler Object.getPrototypeOf(person1).sayName(); //Nicholas delete person1.name; person1.sayName(); //Nicholas delete Object.getPrototypeOf(person1).name; person1.sayName(); //undefined 使用hasOwnProperty()方法可以检测一个属性是否存在于实例中，还是存在于原型中。这个方法只在给定属性存在于对象实例中时，才会返回true，如下所示： function Person() {} Person.prototype.name = &quot;Nicholas&quot; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function () { console.log(this.name); } var person1 = new Person(); var person2 = new Person(); person1.name = &quot;Eviler&quot;; console.log(person1.hasOwnProperty(&quot;name&quot;)); //true console.log(person2.hasOwnProperty(&quot;name&quot;)); //fasle ECMAScript 5的Object.getOwnPropertyDescriptor()方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescriptor()方法，如： Object.getOwnPropertyDescriptor(Object.getPrototypeOf(person1), &quot;name&quot;) 原型与 in 操作符有两种方法使用 in 操作符：单独使用和在for-in循环中使用。在单独使用时，in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中，如下所示： function Person() {} Person.prototype.name = &quot;Eviler&quot;; var person1 = new Person(); var person2 = new Person(); person1.age = 22; console.log(&quot;age&quot; in person1); //true console.log(&quot;name&quot; in person2); //true console.log(&quot;job&quot; in person2); //false 所以我们可以用 in 操作符和 Object.hasOwnProperty()来确定一个属性是否为原型属性： console.log((&quot;name&quot; in person1) &amp;&amp; !person1.hasOwnProperty(&quot;name&quot;)); 在使用for-in循环时，返回的是所有能够通过对象访问、可枚举(enumerated)属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的（IE8及更早版本中例外）。要取得对象上所有课枚举的实例属性，可以使用ECMAScript 5的Object.keys()方法，这个方法接受一个对象作为参数，返回一个包含所有课枚举属性的字符串数组。例如： function Person() {} Person.prototype.name = &quot;Nicholas&quot; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function () { console.log(this.name); } var person1 = new Person(); var person2 = new Person(); for (var key in person1) { console.log(key); } /* 打印结果 name age job sayName */ console.log(Object.keys(person1)); /* 打印结果 [] */ 还可以使用Object.getOwnPropertyNames()方法获取所有实例属性，不论它是否可枚举，如下所示： console.log(Object.getOwnPropertyNames(Object.getPrototypeOf(person1))); // [ &apos;constructor&apos;, &apos;name&apos;, &apos;age&apos;, &apos;job&apos;, &apos;sayName&apos; ] 更简单的原型语法function Person() {} Person.prototype = { name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName: function () { console.log(this.name); } } 这样创建的效果就和前面那样创建的效果一样了，但是有一点不一样: constructor属性不再指向Person了，前面说过，每创建一个函数，就会同时创建它的prototype对象，这个对象也会自动获得constructor属性。而我们在这里使用的语法，本质是是完全重写了默认的prototype对象，因此constructor属性属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。此时，使用 instanceof 操作符能返回正确的结果，但是不能通过constructor 来确定对象的类型。如果constructor真的很重要，可以特意将它设置回适当的值(但是这样会使constructor的[[enumerable]]特征被设置为true)： function Person() {} Person.prototype = { constructor: Person, name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName: function () { console.log(this.name); } } 原型的动态性由于原型中查找值得过程是一次搜索，因此我们对原型对象上所做得任何修改都能够立即从实例上反应出来—即使先创建了实例后修改原型也照样如此，如下所示： function Person() {} Person.prototype = { name: &quot;Eviler&quot;, sayName: function () { console.log(this.name); } } var person = new Person(); person.sayName(); Person.prototype.sayHi = function () { console.log(&quot;hi&quot;); } person.sayHi(); //hi (调用成功，即使先创建了实例) 其原因可以归根结底为实例与原型直接得松散连接关系（实例与原型之间得连接只不过是一个指针，而非一个副本）。但是如果是重写整个原型对象，那情况就不一样了，因为重写原型对象会切断构造函数与最初原型之间的联系。 原生对象的原型原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等待）都在其构造函数的原型上定义了方法。例如，在Array.prototype中可以找到sort()方法，而在String.prototype中可以找到substring()方法。这样，通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法，还可以修改原生对象的方法（不建议）。 原生对象的问题 忽略了为构造函数传递初始化参数这一环境，结果所有实例在默认情况下都将取得相同的属性值 共享的本性导致的问题，这是最大的问题。原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值得属性倒也说的过去，毕竟通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值得属性来说，问题就比较突出了，看下面的示例： function Person() {} Person.prototype = { name: &quot;Eviler&quot;, age: 22, skills: [&quot;English&quot;, &quot;javascript&quot;], sayName: function () { console.log(this.name); } } var person1 = new Person(); var person2 = new Person(); console.log(person1.skills); //[ &apos;English&apos;, &apos;javascript&apos; ] person2.skills.push(&quot;python&quot;); console.log(person1.skills); //[ &apos;English&apos;, &apos;javascript&apos;, &apos;python&apos; ] 在这个例子中，person1和person2共享了属性原型对象的skills属性，所以，person2改变它的值，person1的skills也就变了。但是，实例一般都是要有属于自己的全部属性的。所以我们需要一种方法来解决这个问题。这就出现了组合使用构造函数和原型模式。 组合使用构造函数和原型模式这是创建自定义类型最常见的方法。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果每个实例都会有自己的一份实例属性但又同时共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持像构造函数传递参数；可谓是集两种模式之长。下面的代码重写了前面的例子： function Person(name, age, job) { this.name = name; this.age = age; this.job = job; } Person.prototype = { sayName: function () { console.log(this.name); } } 动态原型模式这个模式是受到其他OO语言封装性的影响而产生的一种模式，其实它也是组合使用构造函数和原型模式，只不过它看起来更舒服一些，因为它将所有信息都封装在了构造函数中，同时又保存了组合使用构造函数和原型模式的优点。它可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型，如下示例（重写上面的示例）:function Person(name, age, job) { this.name = name; this.age = age; this.job = job; if (typeof !Person.sayName == “function”) { Person.prototype.sayName = function () { console.log(this.name); } }}使用动他原型模式时，不能使用对象字面量重写原型，如果在以及创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。 寄生构造函数模式通常，在前述的几种模式都不适用的情况下，可以使用寄生构造函数模式。如下所示： function Person(name, age, job) { var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function () { console.log(this.name); } return o; } var p = new Person(&quot;Eviler&quot;, 22, &quot;Software Engineer&quot;); p.sayName(); //Eviler 这个模式其实跟工程模式其实是一模一样的，都无法检测对象类型。非要说它们的区别，那么就是函数名了如果是工程模式，我们会把函数名定义为createPerson，而使用寄生构造函数模式，直接将函数名定义为构造函数的样子Person，并且使用了new 操作符来创建实例。 稳妥构造函数模式稳妥对象：没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境会进制使用this和new），或者在防止数据被其他应用程序（如Mashuo程序）改的时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：意识新创建对象的实例方法不引用this；二是不适应new 操作符调用构造函数。重写前面的示例： function Person(name, age, job) { var o = new Object(); o.sayName = function () { console.log(name); } return o; } var person = new Person(&quot;Eviler&quot;, 22, &quot;Software Engineer&quot;); person.sayName(); //Eviler 在这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。这样person中保存的是一个稳妥对象。 继承许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。在ECMAScript中，由于函数没有签名，无法实现接口继承，只支持实现继承，而其实现继承主要是依靠原型链来实现的。 原型链利用原型让一个引用类型继承另一个引用类型的属性和方法。构造函数、原型和实例之间的关系是：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如让原型对象等于另一个类型的实例，结果会是怎样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然城里，如此层次递进，就构成了实例与原型的链条，这就是原型链的基本概念。以下代码为实现原型链的一种基本模式： function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function () { return this.property; } function SubType() { this.subproperty = false; } //继承了SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function () { return this.subproperty; } var instance = new SubType(); console.log(instance.getSuperValue()); //true console.log(instance.getSubValue()); //false 这样，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。这个例子中的实例以及构造函数和原型之间的关系如图所示： 构造函数、原型和实例关系图 注意：instance.constructor 现在指向的是SuperType，这是因为原来SubType.prototype中的constructor被重写了。实际上，不是SubType的原型的constructor属性被重写了，而是SubType的原型指向了另一个对象—-SuperType的原型，而是这个原型对象的constructor属性指向的是SuperType。 勿忘记默认的原型前面的原型链还少一环。我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针指向Object.prototype。这正数所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。所以原型链中还应该包括另一个继承层次，如图： 确定原型和实例的关系可以通过两种方式来确定原型和实例之间的关系。 第一种是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。 console.log(instance instanceof SubType); //true console.log(instance instanceof SuperType); //true console.log(instance instanceof Object); //true 第二种方法是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true。 console.log(SubType.prototype.isPrototypeOf(instance)); //true console.log(SuperType.prototype.isPrototypeOf(instance)); //true console.log(Object.prototype.isPrototypeOf(instance)); //true 谨慎地定义方法子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。并且不能使用对象字面量创建方法，因为这样做回重写原型链。 原型链的问题最主要的问题就是来自包含引用类型的原型。包含引用类型值得原型属性会被所有实例共享，这正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。但是通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺利成章地变成了现在的原型属性了。如下代码： function SuperType() { this.colors = [&quot;read&quot;, &quot;blue&quot;, &quot;green&quot;]; } function SubType() {} SubType.prototype = new SuperType(); var instance1 = new SubType(); instance1.colors.push(&quot;back&quot;); console.log(instance1.colors); //[&apos;read&apos;,&apos;blue&apos;,&apos;green&apos;,&apos;back&apos;] var instance2 = new SubType(); console.log(instance2.colors); //[&apos;read&apos;,&apos;blue&apos;,&apos;green&apos;,&apos;back&apos;] 这样，所有实例都会共享某些属性（引用类型），显然这样的继承不是我们想要得到的结果。原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该是没有办法在不影响所有实例的情况下，给超类型的构造函数传递参数。所以，实践中很少会单独使用原型链。 借用构造函数借用构造函数，有时候也叫做伪造对象或经典继承。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超型构造函数，s函数只不过是在特定环境中指向代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上指向构造函数，如下所示： function SuperType() { this.colors = [&quot;read&quot;, &quot;blue&quot;, &quot;green&quot;]; } function SubType() { // 继承了SuperType SuperType.call(this);//或者使用apply()函数 } var instance1 = new SubType(); instance1.colors.push(&quot;back&quot;); console.log(instance1.colors); //[&apos;read&apos;,&apos;blue&apos;,&apos;green&apos;,&apos;back&apos;] var instance2 = new SubType(); 这样，在SubType的构造函数中“借调”了超类型的构造函数，这样就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。借用构造函数可以在子类型构造函数中向超类型构造函数传递参数 function SuperType(name) { this.name = name; } function SubType() { // 继承了SuperType,同时还传递了参数 SuperType.call(this, &quot;Eviler&quot;); //实例属性 this.age = 22; } var instance = new SubType(); console.log(instance.name); //Eviler console.log(instance.age); //22 借用构造函数的问题：如果仅仅借用构造函数，那么无法避免构造函数模式存在的问题—-方法都在构造函数中定义，因此函数复用就无从谈起。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。所以，借助构造函数的技术也是很少单独使用的。 组合继承组合继承有时候也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而返回二者之长的一种继承模式。其背后的思路是使用原型链实现对原型方法的继承，而通过借用构造函数来实现对实例属性的继承。如下所示： function SuperType(name) { this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; } SuperType.prototype.sayName = function () { console.log(this.name); } function SubType(name, age) { //继承属性 SuperType.call(this, name); //自己新加的属性 this.age = age; } //继承方法 SubType.prototype = new SuperType(); SubType.prototype.sayAge = function () { console.log(this.age); } var instance1 = new SubType(&quot;Eviler&quot;, 22); instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); //[&quot;read&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]; instance1.sayName(); //Eviler instance1.sayAge(); //22 var instance2 = new SubType(&quot;Greg&quot;, 25); console.log(instance2.colors); //[&quot;read&quot;, &quot;blue&quot;, &quot;green&quot;]; instance2.sayName(); //Greg instance2.sayAge(); //25 这样就解决了原型链模式继承的所有实例共享超类型实例的引用属性的问题和借用构造函数模式的函数复用问题。而且，instanceof和isPrototypeOf()特能够用于识别基于组合继承创建的对象。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://eviler.top/tags/javascript/"}]},{"title":"Javascript操作符","date":"2019-04-07T12:12:18.000Z","path":"articles/javascript-operator/","text":"ECMAScript描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。它们能够使用很多值，例如字符串、数字值、布尔值、甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。 一元操作符递增(++)和递减操作符(–)递增和递减操作符遵循下列规则 应用于包含有效数字字符的字符串，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。 应用于布尔值时，true转换为1，false转换为0，再执行加减1的操作。布尔值变成数值变量。 应用于浮点数值时，执行加减1的操作 应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN。字符串变量变成数值变量。 应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对改制应用签署规则。如果结果是NaN，则再调用toString()方法后再应用签署规则。对象变量变成数值变量。 一元加(+)和减(-)操作符一元加操作符放在数值前面，对数值不会产生任何影响。不过，在对非数值应用一元加操作符时，该操作符会像Number()转型函数（可查看上一篇文章）一样对这个值执行转换。一元减操作符主要用于表示负数。将一元操作符应用于数值时，该数值会变成负数。而当应用于非数值时，一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数。 位操作符位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript中的所有数值都以IEEE-754 64位格式存储，但未操作并不直接操作64位的值。而是先将64位的值转换为32位的整数，然后执行操作，最后再将结果转换回64位。对于有符号的整数，32位中的前31位用于表示整数的值。第32位（符号位）用于表示数值的符号：0表示正数，1表示负数。负数使用二进制存储，但使用的格式是二进制补码。计算一个数值的二进制补码需要经过三个步骤： 求这个数值绝对值的二进制码（例如，要求-18的二进制补码，先求18的二进制码） 求二进制反码，即将0替换为1，将1替换为0 得到的二进制反码加1 按位非(NOT)用一个波浪线(~)表示，操作数只有一个，执行按位非得结果就是返回数值的反码。 var num1 = 25; //二进制00011001 var num2 = ~num1; //二进制11100110 按位与(AND)按位与用和字号(&amp;)表示，操作数有两个，从本质上将，按位与就是将两个数值的每一位对齐，对相同位置上的两个数执行AND操作 var result = 25 &amp; 3; //11001 &amp; 00011 = 00001 console.log(result); //1 按位或(OR)按位与用和竖线符号(|)表示，操作数有两个，从本质上将，按位与就是将两个数值的每一位对齐，对相同位置上的两个数执行OR操作 var result = 25 | 3; //11001 | 00011 = 11011 console.log(result); //27 按位异或(XOR)按位与用和竖线符号(^)表示，操作数有两个，从本质上将，按位与就是将两个数值的每一位对齐，对相同位置上的两个数执行XOR操作(相同则为0，不相同则为0) var result = 25 | 3; //11001 ^ 00011 = 11010 console.log(result); //26 左移左移操作由两个小于号(&lt;&lt;)表示 var result = 2 &lt;&lt; 3; //00010 &lt;&lt; 3 = 10000 console.log(result); //16 有符号右移右移操作由两个大于号(&gt;&gt;)表示 var result = 16 &gt;&gt; 3; //10000 &gt;&gt; 3 = 00010 console.log(result); //2 var result2 = 16 &gt;&gt; 5; //10000 &gt;&gt; 3 = 00010 console.log(result2); //0 无符号右移有符号的右移操作符由3个大于号(&gt;&gt;&gt;)表示，会将数值的所有32位都向右移动对正数来说，无符号右移的结果和有符号右移结果相同对负数来说，结果不一样，无符号右移操作符会把负数的二进制码当成正数的二进制码，由于负数以其绝对值的二进制补码形式表述，因此会导致无符号右移的结果非常大 var oldValue = -64; //等于二进制的11111111111111111111111111000000 var newValue = oldValue &gt;&gt;&gt; 5 //等于十进制的134217726 布尔操作符共有三个：非(NOT)、与(AND)和或(OR) 逻辑非由一个叹号(!)表示, 有以下规则： console.log(!{}); //对象：返回false console.log(!&quot;&quot;); //空字符串：返回true console.log(!&quot;hello&quot;); //非空字符串：返回false console.log(!0); //0：返回true console.log(!9); //非0数，包括Infinity：返回false console.log(!Infinity); console.log(!null); //null：返回true console.log(!NaN); //NaN：返回true console.log(!undefined); //undefined：返回true 逻辑与由两个和号(&amp;&amp;)表示，它是一个短路操作符，结果不一定返回布尔值，遵循以下规则： 如果第一个操作数为false，不论第二个操作数为任何值，返回结果都为false 如果第一个操作数为对象，则返回第二个操作数 如果两个操作数都为对象，则返回第二个操作数 如果第一个操作数为null、NaN或undefined则返回第一个操作数 console.log({age:12} &amp;&amp; 27);//{age:12} console.log(true &amp;&amp; {age:12});//{age:12} console.log({age: 12} &amp;&amp; {age: 18});//{age:18} console.log(null &amp;&amp; true);//null console.log(false &amp;&amp; null);//false console.log(NaN &amp;&amp; true);//NaN console.log(false &amp;&amp; NaN);//false console.log(undefined &amp;&amp; true);//undefined console.log(false &amp;&amp; undefined);//false 逻辑或由两个竖线符号(||)表示，它也是一个短路操作符，结果不一定返回布尔值，遵循以下规则： 如果第一个操作数的求值结果为true，则返回true，不会对第二个操作数求值 如果第一个操作数的求值结果为false，则返回第二个操作数 如果两个操作数都为对象，则返回第一个操作数 两个操作数都为null、NaN或undefined，则返回对应的值 console.log({} || 27); //{} console.log(false || {}); //{} console.log({age:12} || {age:18}); //{age:12} console.log(null || true); //true console.log(true || null); //true console.log(false || null);//null console.log(NaN || true); //true console.log(false || NaN); //NaN console.log(undefined || true);//true console.log(false || undefined);//undefined console.log(null || null); //null console.log(NaN || NaN); //NaN console.log(undefined || undefined); //undefined 乘性(*,/)、加性(+,-)操作符乘法 如果由一个操作数是NaN，则结果为NaN Infinity与0相乘，结果为NaN Infinity与非0数相乘，结果为Infinity或Infinity，符号取决于有符号数的符号 Infinity与Infinity相乘，结果为Infinity console.log(Infinity * 0); //NaN console.log(Infinity * 4); //Infinity console.log(Infinity * -4); //-Infinity console.log(-Infinity * -4); //Infinity console.log(Infinity * Infinity); //Infinity console.log(Infinity * -Infinity); //-Infinity 除法 如果由一个操作数是NaN，则结果为NaN Infinity被Infinity除，结果为NaN 0被0除，结果为NaN 非0有限数被0除，结果为Infinity或Infinity Infinity被任何非0数值除，结果为Infinity或Infinity console.log(Infinity / Infinity); //NaN console.log(0 / 0); //NaN console.log(8 / 0); //NaN console.log(Infinity / 6); //Infinity console.log(Infinity / -6); //-Infinity console.log(-Infinity / -6); //Infinit 加法 如果由一个操作数是NaN，则结果为NaN Infinity加-Infinity，结果为NaN +0加+0，结果为+0；-0加-0,结果为-0；+0加-0，结果为+0 如果有一个操作数为字符串，则将另一个操作数转换为字符串，再将字符串拼接起来，操作数为对象、数值或布尔值，调用它们的toString()方法取得相应的字符串；undefined和null，分别调用String()函数取得字符串”undefined”和”null” console.log(5 + 5); //10 console.log(5 + &quot;5&quot;); //&quot;55&quot; console.log(&quot;&quot; + undefined); //&quot;undefined&quot; console.log(&quot;&quot; + null); //&quot;null&quot; 减法 如果由一个操作数是NaN，则结果为NaN Infinity减Infinity，结果为NaN -Infinity减-Infinity，结果为NaN Infinity减-Infinity，结果为Infinity -Infinity减Infinity，结果为-Infinity +0减+0，结果为+0；-0减-0,结果为+0；+0减-0，结果为-0 如果一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转化为数值，然后再进行减法操作；如果有一个操作数是对象，则先后调用对象的valueOf和toString()方法看能不能将其转化为数值再进行运算 关系操作符小于(&lt;)、大于(&gt;)、小于等于(&lt;=&gt;)和大于等于(&gt;=) 如果两个操作数都是数值，则执行数值比较 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值 如果一个操作数为数值，则将另一个操作数转换为一个数值再进行比较 如果一个操作数为对象，则先后调用对象的valueOf和toString()方法看能不能将其转化为数值再进行比较 NaN与任何数比较，不管使用哪种关系操作符，结果都为false 相等操作符相等(==)和不相等(!=) 如果有一个操作数为布尔值，则先将其转化为数值：false-&gt;0,true-&gt;1 如果一个操作数是字符串，另一个是数值，则先将字符串转换为数值 如果一个操作数为对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较。 两个操作数再进行比较时要遵循：null和undefined是相等的，不能将bull和undefined转换成其他任何值；只要有一个操作数是NaN，则返回结果为false（NaN==NaN返回false）；如果两个操作数都是对象，则比较它们是不是同一个对象。 console.log(null == undefined); //true console.log(&quot;NaN&quot; == NaN); //false console.log(NaN == NaN); //false console.log(NaN != NaN); //true console.log(false == 0); //true console.log(&quot;false&quot; == 0); //false console.log(true == 1); //true console.log(true == 2); //false console.log(undefined == 0); //false console.log(null == 0); //false console.log(&quot;5&quot; == 5); //true 全等(===)和不全等(!==)在连个操作数未经转换的情况下进行相等比较 console.log(null === undefined); //false console.log(&quot;NaN&quot; === NaN); //false console.log(NaN === NaN); //false console.log(NaN !== NaN); //true console.log(false === 0); //false console.log(&quot;false&quot; === 0); //false console.log(true === 1); //false console.log(true === 2); //false console.log(undefined === 0); //false console.log(null === 0); //false console.log(&quot;5&quot; === 5); //false console.log(5 === 5); //true 条件运算符语法：variable = boolean_expression? true_value : false_value;举例： var max = (num1 &gt; num2)? num1: num2; //如果num1大于num2，则max=num1，否则max=num2 赋值操作符简单的赋值操作符有等于号(=)表示，在等号前面加上其他操作符，就可以完成复合赋值操作如： var num = 10; num = num + 10; 可有等价的符合赋值语句实现： var num = 10; num += 10; 每个主要算数操作符都有对应的符合操作符，如下：乘/赋值(*=)、除/赋值(/=)、模/赋值(%=)、加/赋值(+=)、减/赋值(-=)、左移/赋值(&lt;&lt;=)、有符号右移/赋值(&gt;&gt;=)、无符号右/移赋值(&gt;&gt;&gt;=) 逗号操作符可以在一条语句中执行多个操作 var num1 = 1, num2 = 2, num3 = 3; 还可以用于赋值，在用于赋值时，逗号操作符总会返回表达式中的最后一项 var num = (5,1,9,3); console.log(num);//3","tags":[{"name":"javascript","slug":"javascript","permalink":"https://eviler.top/tags/javascript/"}]},{"title":"Javascript数据类型","date":"2019-04-07T03:16:43.000Z","path":"articles/javascript-data-type/","text":"ECMAScript6之前，ECMAScript中有6种原始数据类型，包括5种简单数据类型（也称为基本数据类型）: Undefined、Null、Boolean、Number、String和一种复杂数据类型: Object（本质上是由一组无序的名值对组成），ECMAScript6(ES6)引入了一种新的元素数据类型: Symbol，表示独一无二的值。ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述7种数据类型之一。 typeof操作符由于ECMAScript是松散类型的，因此需要有一种手段来检测给定变量的数据类型—-typeof就是负责提供这方面信息的操作符，对一个值使用typeof操作符可能返回下列某个字符串： “undefined”—-如果这个值未定义 “boolean”—-如果这个值是布尔值 “string”—-如果这个值是字符串 “number”—-如果这个值是数值 “object”—-如果这个值是对象或null “function”—-如果这个值是函数 “symbol”—-如果这个值是Symbolconsole.log(typeof notDefined); //undefined console.log(typeof true); //boolean console.log(typeof &quot;hello&quot;); //string console.log(typeof 4.00); //number console.log(typeof NaN); //number console.log(typeof null); //object console.log(typeof {name: &quot;Eviler&quot;}); //object console.log(typeof function f() {}); //function console.log(typeof Symbol()); //symbol 注意： typeof是一个操作符而不是函数 调用 typeof null会返回”object”,因为特殊值null被认为是一个空的对象引用 Safari 5 及之前版本、Chrome 7 及之前版本在对正则表达式调用 typeof 操作符时会返回”function”, 而其他浏览器在这种情况下会返回”object” 从技术角度讲，函数在ECMAScript中是对象，不是一种数据类型，但是函数确实有一些特殊的属性，因此通过 typeof 操作符来区分函和其他对象是有必要的。console.log(typeof f); //function console.log(typeof function () {}); //function console.log(typeof new Function(&quot;&quot;, &quot;return hello-world&quot;)); //function Undefined类型Undefined类型只有一个值，即特殊的undefined，在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined，例如：var message; console.log(message === undefined) //true 这个值是在ECMA-262第三版引入的，是为了正式区分空对象与未经初始化的变量包含undefined值的变量与尚未定义的变量是不一样的var message; console.log(message) //undefined console.log(age) // Uncaught ReferenceError: age is not defined (引用错误：age没有定义) 对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型（对未经声明的变量调用delete不会导致错误，但这样做没有什么实际意义，而且在严格模式下确实会导致错误）对未初始化和未声明的变量执行 typeof 操作符都返回了undefined值；这个结果有逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。 Null类型Null类型是i第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也整数 typeof 操作符检测 null 时会返回 “object” 的原因。如果定义的变量准备在将来用于保存对象，那么最好讲该变量初始化为null而不是其他值。实际上， undefined 值是派生自 null 值的，因此ECMA-262规定对它们的相等性测试要返回true console.log(null == undefined); //true Boolean类型Boolean类型只有两个字面值：true 和 false 。这两个值和数字值不是一回事，因此true不一定等于1，而false也不一定等于0ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()。下标给出了各种数据类型及其对应的转换规则： 数据类型 转换为true的值 转换为false的值 Boolean true false String 任何非空字符串 “” (空字符串) Number 任何非零数字值(包括无穷大) 0和NaN Object 任何对象 null Undefined undefined Number类型ECMAScript使用这种类型类表示整数和浮点数值，ECMA-262定义了不同的数值字面量格式 var intNum = 55; //十进制整数 var binNum = 0b1010; //二进制数的10（ES6） var octalNum = 070; //八进制的56（ES6中使用0o前缀来定义八进制数） var hexNum = 0x1f; //十六进制的31 在进行算数计算时，所有以二进制、八进制和十六进制表示的数值最终都将被转换成十进制数值 浮点数值该数值必须包含一个小数点，并且小数点后面必须至少有一位数字 var floatNum = 0.1; 保存浮点数值需要的内存空间时保存整数值的两倍，ECMAScript会不失时机地将浮点数值转换为整数值。如果小数点后面没有跟任何数字或者浮点数本身表示的就是一个整数（如1.0），那么该值也会被转换为整数 var floatNum1 = 1.; //小数点后面没有数字----解析为1 var floatNum2 = 10.0; //整数----解析为10 对于极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值表示。 var floatNum1 = 3.125e7; //等于31250000 var floatNum2 = 3e-10; //等于0.0000000003 浮点数值的最高精度是17位小数，但在进行算数计算时其精度远远不如整数，如：0.1+0.3结果不是0.3，而是0.30000000000000004，所以，永远不要测试某个特定的浮点数值（如：a+b==0.3） 数值范围ECMAScript能够表示的最小数为 Number.MIN_VALUE，大多数浏览器中，这个值为5e-324ECMAScript能够表示的最大数为 Number.MAX_VALUE，大多数浏览器中，这个值为1.7976931348623157e+308如果某次计算的结果得到了一个超过Javacsript范围的值，那么之歌数值将被自动转化成特殊的Infinity值，如果是负数，则为 -Infinity（负无穷），如果是正数，则为 Infinity（正无穷）被转换为Infinity的值是无法参与下一次运算的。可用 isFinite() 函数判断某个数值是不是又穷的 console.log(isFinite(3)); //true console.log(isFinite(Infinity)); //false 另外 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 分别保存着 -Infinity 和 Infinity console.log(Number.NEGATIVE_INFINITY == -Infinity); //true console.log(Number.POSITIVE_INFINITY == Infinity); //true NaNNaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在ECMA中，任何数值除以0会返回NaN，因此不会影响到其他代码的执行。NaN的两个特点： 任何涉及NaN的操作（如NaN/10）都会返回NaN NaN与任何值都不相等，包括NaN本身针对NaN的这两个特点，ECMAScript定义了isNaN()函数console.log(isNaN(NaN)); //true console.log(isNaN(10)); //false(10是一个数值) console.log(isNaN(&quot;10&quot;)); //false(可以被转化成数值10) console.log(isNaN(&quot;blue&quot;)); //true(不能转换成数值) console.log(isNaN(true)); //false(可以被转换成数值1) isNaN()适用于对象，在基于对象调用isNaN()函数时，会首先调用对象的valueOf()方法，然后确定该放大返沪的值是否可以转换为数值。如果不能，则基于这个返回值再调用toString()方法，再测试返回值。数值转换有三个函数可以把非数值转换为数值：Number、parseInt()和parseFloat() Number()转换规则： Boolean值: true -&gt; 1 ; false -&gt; 0 数字值: 简单传入和返回 null值: 0 undefined值: NaN 字符串: &#12288;&#12288;只包含数字（包括前面带正负号） -&gt; 十进制数 &#12288;&#12288;只包含有效的浮点格式 -&gt; 对应的浮点数值 &#12288;&#12288;只包含有效的十六进制格式 -&gt; 对应的十进制整数 &#12288;&#12288;空 -&gt; 0 &#12288;&#12288;包含上述格式之外的字符 -&gt; NaN 对象：调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象toString()方法，然后依照前面的规则转换返回的字符串值。 parseInt()parseInt()在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个不是数字字符或者负号，parseInt()就会返回NaN; 如果第一个字符是数字字符，parseInt()就会继续解析第二个字符，直到解析完所有后序字符或者遇到了一个非数字字符。parseInt()也能够识别出各种整数格式（八进制、十六进制） console.log(parseInt(&quot; &quot;)); //NaN console.log(parseInt(&quot; 110test&quot;)); //110 console.log(parseInt(&quot;22.5&quot;)); //22 console.log(parseInt(&quot;0b11&quot;)); //0 console.log(parseInt(&quot;017&quot;)); //17(ECMAScript3 认为是15：八进制数，ECMAScript5认为是17：十进制数) console.log(parseInt(&quot;19&quot;)); //19 console.log(parseInt(&quot;0x1f&quot;)); //31 ECMAScript5 Javascript引擎中parseInt()已经不具有解析八进制的能力，因此前导0会被认为无效，为了消除在使用parseInt()函数是肯导致的上述困惑，可以给这个函数提供第二个参数，明确地告诉函数转换时使用的基数（即多少进制），例如: console.log(parseInt(&quot;11&quot;, 2)); //3 console.log(parseInt(&quot;11&quot;, 8)); //9 console.log(parseInt(&quot;11&quot;, 10)); //11 console.log(parseInt(&quot;11&quot;, 16)); //17 其中如果第二个参数为16, 要转化的字符串可以有前导0x也可以无前导0x其实这个函数不仅限与2、8、10、16进制的数值字符串转化为十进制数值，第二个参数传2-36都能够得到我们想要的结果： console.log(parseInt(&quot;11&quot;, 4)); //5 console.log(parseInt(&quot;1b&quot;, 12)); //23 console.log(parseInt(&quot;11&quot;, 36)); //37 console.log(parseInt(&quot;1z&quot;, 36)); //71 parseFloat()与parseInt()函数类似，parseFloat()也是从第一个字符开始解析每个字符。而且一直解析到字符串的末尾，或者解析遇见一个无效的浮点数字字符位置。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的，因此它后面的字符串将会被忽略，例如：”22.34.5”-&gt;22.34除了第一个小数点有效之外，与parseInt()和parseFloat()的第二个区别在与它始终都会忽略前导的0，parseFloat()只解析十进制数。如果字符串包含的是一个课解析为整数的数（没有小数点，或者小数点后都是0），parseFloat()会返回整数 console.log(parseFloat(&quot;1234test&quot;)); //1234 console.log(parseFloat(&quot;0xA&quot;)); //0 console.log(parseFloat(&quot;22.5&quot;)); //22.5 console.log(parseFloat(&quot;22.34.5&quot;)); //22.34 console.log(parseFloat(&quot;0908.5&quot;)); //908.5 console.log(parseFloat(&quot;3.125e7&quot;)); //31250000 String类型String类型用于表示由0或者多个Unicode字符组成的字符序列，可由双引号(“)或单引号(‘)表示 字符串的特点ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，他们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，例如： var lang = &quot;Java&quot;; lang = lang + &quot;Script&quot;; 将变量lang的值从”Java”变成”JavaScript”实际上经过了以下过程：首先创建一个能容纳10个字符串的新字符型，然后在这个字符串中填充”Java”和”Script”,最后一步是销毁原来的字符串”Java”和字符串”Script”，因为这两个字符串已经没用了。最后这个过程是在后台发生的。 转化为字符串要把一个值转化为字符串由两种方式。第一张是使用几乎每个值都有的toStrin()方法。这个方法唯一要做的就是返回相应值得字符串表现。数值、布尔值、对象、Symbol和字符串（返回字符串得一个副本）都有toString()方法，但null和undefined值没有这个方法。在调用数值得toString()方法时，可以传递一个参数：输出数值的基数(相应的进制数)，例如： var num = 10; var str = &quot;Hello&quot;; console.log(num.toString()); //&quot;10&quot; (默认以十进制格式返回数值的字符串表示) console.log(num.toString(2)); //&quot;1010&quot; console.log(num.toString(4)); //&quot;22&quot; console.log(num.toString(8)); //&quot;12&quot; console.log(num.toString(16)); //&quot;a&quot; console.log((32).toString(32)); //&quot;10&quot; console.log(str.toString(8)); //&quot;Hello&quot;(字符串类型的变量会忽略传给toString()的参数) 在不知道要转换的值是不是Null和Undefined类型的情况下，还可以使用转型函数String();规则：如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果如果值是null，则返回”null”如果值是undefined，则返回”undefined” var s1 = undefined; var s2 = null; console.log(String(true)); //&quot;true&quot; console.log(String(10)); //&quot;10&quot; console.log(s1.toString()); //Uncaught TypeError: Cannot read property &apos;toString&apos; of undefined console.log(s2.toString()); //Uncaught TypeError: Cannot read property &apos;toString&apos; of undefined console.log(String(s1)); //&quot;undefined&quot; console.log(String(s2)); //&quot;null&quot; 要把某个值转化为字符串们可以使用加号操作符把它与一个字符串(“”)加在一起 var s1 = undefined; var s2 = null; console.log(10 + &quot;&quot;); //&quot;10&quot; console.log(s1 + &quot;&quot;); //&quot;undefined&quot; console.log(s2 + &quot;&quot;); //&quot;null&quot; Object类型ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new 操作符后跟要创建的对象类型的名称来创建。Object类型是所有它的实例的基础，换句话说，Object类型所具有的任何属性和方法也同样存在于更具体的对象中。Object的每个实例都具有下列属性和方法 constructor: 保存着用于创建当前对象的函数 hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。 isPrototypeOf(object): 用于检查传入的对象是否是另一个对象的原型 propertyIsEnumerable(propertyName): 用于检测给定的属性是否能够使用for-in语句来枚举 toLocaleString(): 返回对象的字符串表示，该字符串与执行环境的地区对应 toString(): 返回对象的字符串表示 valueOf(): 返回对象的字符串、数值或b布尔值表示。通常与toString()方法的返回值相同。 Symbol类型ES6引入的一种新的原始数据类型，表示独一无二的值。Symbol值通过Symbol()函数生成。这就是说，对象的属性名现在可以有两种数据类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的。 let s = Symbol(); console.log(typeof s); //symbol Symbol()函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了控制台显示，或转为字符串时，比较容易区分 let s1 = Symbol(&quot;foo&quot;); let s2 = Symbol(&quot;bar&quot;); console.log(s1); //Symbol(foo) console.log(s2); //Symbol(bar) console.log(s1); //&quot;Symbol(foo)&quot; console.log(s2); //&quot;Symbol(bar)&quot; 注意：Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的 // 没有参数的情况 let s1 = Symbol(); let s2 = Symbol(); console.log(s1 === s2); // false // 有参数的情况 let s1 = Symbol(&apos;foo&apos;); let s2 = Symbol(&apos;foo&apos;); console.log(s1 === s2); // false","tags":[{"name":"javascript","slug":"javascript","permalink":"https://eviler.top/tags/javascript/"}]},{"title":"使用js实现的数据结构——链表","date":"2019-01-25T11:00:08.000Z","path":"articles/data-structure-algorithm-chain/","text":"链表的定义链表是物理存储单元上非连续的、非顺序的存储结构，由一系列节点组成，下图是一个简单的结构示意图。注意：下面提到的链表，均指单链表。 链表图(图片来自互联网) 节点节点包含两部分，一部分是存储数据元素的数据域，一部分是存储指向下一个节点的指针域，上图中绿色的部分就是数据与，蓝色的部分是指针域，它们一起共同构成一个节点。一个节点可以用如下的方式去定义和使用，示例代码如下： var Node = function(data){ this.data = data; this.next = null; } var node1 = new Node(1); var node2 = new Node(2); var node3 = new Node(3); node1.next = node2; node2.next = node3 console.log(node1.data); //打印结果：1 console.log(node1.next.data); //打印结果：2 console.log(node1.next.next.data); //打印结果：3 首位节点链表中的第一个节点是首节点，最后一个节点是尾节点 有头链表和无头链表无头链表是指第一个节点既有数据域，又有指针域，第一个节点既是首节点又是头节点。有头链表是指第一个节点只有指针域，而没有数据域。 链表的实现代码： //定义链表类 function LinkList() { //定义节点 var Node = function (data) { this.data = data; this.next = null; } var lebgth = 0; //长度 var head = null; //头节点 var tail = null; //尾节点 //添加一个新的元素 this.append = function (data) { var node = new Node(data); //如果是空链表 if (head == null) { head = node; tail = node; } else { tail.next = node; //尾节点指向创建的节点 tail = node; //tail指向链表的最后一个节点 } length++; return true; } //在指定位置插入一个元素 this.insert = function (index, data) { if (index == length) { return this.append(data); //插到尾部 } else if (index &gt; length || index &lt; 0) { //不合理的位置 return false; } else { var new_node = new Node(data); if (index == 0) { new_node.next = head; //新节点的next指向链表的头节点 head = new_node; //头节点赋值为新插入的节点 } else { var insert_index = 1; var current_node = head; //找到应该插入的位置 while (insert_index &lt; index) { current_node = current_node.next; insert_index++; } //找到以后 new_node.next = current_node.next; current_node.next = new_node; } length++; return true; } } //删除指定位置的节点 this.remove = function (index) { if (index &lt; 0 || index &gt; length) { return false; } else { var delete_node = null; if (index = 0) { delete_node = head; //删除的是头节点 head = head.next; //头节点直接指向下一个节点 } else { var del_index = 0; //搜索下标 var pre_node = null; //搜索时当前节点的前一个节点 var current_node = head; //搜索时当当前节点 while (del_index &lt; index) { del_index++; pre_node = current_node; current_node = current_node.next; } del_node = current_node; pre_node.next = current_node.next; if (current_node == null) { //如果要删除的节点是尾节点 tail = pre_node; } } length--; del_node.next = null; //删除的节点的next指向null return del_node.data; //返回删除的节点中的数据 } } //删除头节点 this.remove_head = function () { return this.remove(0) } //删除尾节点 this.remove_tail = function () { return this.remove(length - 1); } //返回指定元素的索引, //如果没有，返回-1 //有多个相同的元素，返回第一个 this.indexOf = function (data) { var current_index = 0; var current_node = head; while (current_node) { if (current_node.data == data) { return current_index; } current_index++; current_node = current_node.next; } return -1; } //返回指定索引位置的元素 this.get = function (index) { var current_index = 0; var current_node = head; if (index &lt; 0 || index &gt;= length) { return null; } while (current_index &lt; index) { current_index++; current_node = current_node.next; } return current_node.data; } //返回首节点的值 this.head = function () { return this.get(0); } //返回尾节点的值 this.tail = function () { return this.get(length - 1); } //返回链表长度 this.length = function () { return length; } //判断链表是否为空 this.isEmpty = function () { return length == 0; } //清空链表 this.clear = function () { head = null; tail = null; length = 0; } //打印整个链表 this.print = function () { var current_node = head; var str_link = &quot;&quot; while (current_node) { console.log(current_node.data); str_link += current_node.data.toString() + &quot;-&gt;&quot;; current_node = current_node.next; } str_link += &quot;null&quot;; console.log(str_link); console.log(&quot;长度为&quot; + length.toString()); } } 基于链表实现的Stack和Queue基于链表实现的Stack链表尾部为栈顶 function Stack() { var linklist = new LinkList(); //从栈顶添加元素 this.push = function (item) { linklist.append(item); } //弹出栈顶元素 this.pop = function () { return linklist.remove_tail(); } //返回栈顶元素 this.top = function () { return linklist.tail(); } //返回栈的大小 this.size = function () { return linklist.length(); } //判断栈是否为空 this.isEmpty = function () { return linklist.isEmpty() } //清空栈 this.clear = function () { linklist.clear(); } } 基于链表实现的Queuefunction Queue() { var linklist = new LinkList(); //入队 this.enqueue = function (item) { linklist.append(item); } //出队 this.dequeue = function () { return linklist.remove_head(); } //返回队首 this.head = function () { return linklist.head(); } //大小 this.size = function () { return linklist.length(); } //判断是否为空 this.isEmpty = function () { return linklist.isEmpty(); } //清空队列 this.clear = function () { linklist.clear(); } }","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://eviler.top/tags/数据结构/"},{"name":"javascript","slug":"javascript","permalink":"https://eviler.top/tags/javascript/"}]},{"title":"使用js实现数据结构——队列","date":"2019-01-21T02:16:56.000Z","path":"articles/data-structure-algorithm-queue/","text":"什么是队列队列这个名词在我们日常生活中并不陌生，在很多场景下，我们都需要排队来进行活动，比如取食堂排队打饭，还有排队购票等。它们都有个有共同的特点就是先来先办理某种业务，后来的只能排在队尾等候。今天所要讲的队列是一种数据结构，是一种特殊的线性表，它只允许在队列头部（队头）进行删除操作，在队列的尾部（队尾）进行插入操作。 入队与出队图示入队 队列入队演示(图片来自互联网) 出队 队列出队演示(图片来自互联网) 代码实现function Queue() { var items = []; //向队列尾部添加一个元素 this.enqueue = function (item) { items.push(item); } //从队列头部移除一个元素 this.dequeue = function () { return items.shift(); //js数组对象自带的函数 } //返回队列头部元素 this.head = function () { return items.length &gt; 0 ? items[0] : null; } //返回队列大小 this.size = function () { return items.length; } //清空队列 this.clear = function () { items = []; } //判断否否为空队列 this.isEmpty = function () { return items.length == 0; } } 队列使用实例题目一有一个数组a[100]存放0–99；要求每隔两个数删掉一个属，到末尾时循环至开头继续进行，求最后一个被删掉的数 代码示例： function del_ring(arr_list) { var queue = new Queue(); for (var i = 0; i &lt; arr_list.length; i++) {//将数组里面的数都放入队列中 queue.enqueue(arr_list[i]) } var index = 0; while (queue.size() != 1) { //弹出一个元素，判断是否需要删除 var item = queue.dequeue(); index += 1; //每个两个就要删除一个，如果不是被删除的元素就加到队列尾部 if (index % 3 != 0) { queue.enqueue(item); } } return queue.head(); } //测试代码 var arr_list = [];//准备数组a for (var i = 0; i &lt; 100; i++) { arr_list.push(i) } console.log(del_ring(arr_list)); //打印结果：90 题目二使用队列计算斐波那契数列的第n项 代码示例： function fibonacci(n) { var queue = new Queue(); queue.enqueue(1); queue.enqueue(1); for (var i = 1; i &lt;= n - 2; i++) { var head_num = queue.dequeue(); queue.enqueue(head_num + queue.head()); } queue.dequeue(); return queue.head(); } console.log(fibonacci(9)); //打印结果：34","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://eviler.top/tags/数据结构/"},{"name":"javascript","slug":"javascript","permalink":"https://eviler.top/tags/javascript/"}]},{"title":"使用js实现的栈以及使用栈实现的几个简单算法","date":"2019-01-19T02:20:34.000Z","path":"articles/data-structure-algorithm-stack/","text":"使用javascript语言实现栈这个数据结构，并且实现几个使用栈来实现的算法。 栈的定义栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。（百度百科） 栈的工作特点后进先出(Last In First Out) 栈的工作特点图解(图片来自互联网) 栈的实现栈的数据存储可以使用数组或者链表做基础，链表也是一种数据结构，后面会单独讲解，所以我使用数组作为基础来实现栈栈通常有以下几个方法 push：添加一个元素到栈顶 pop：弹出一个栈顶元素 top：返回栈顶元素 isEmpty：判断栈是否为空 size：返回栈里元素的个数 clear：清空栈代码实现function Stack() { var items = []; //使用数组存储数据 //push方法向栈里压入一个元素 this.push = function (item) { items.push(item); } //pop方法把栈顶的元素弹出 this.pop = function () { return items.pop(); } //top方法返回栈顶元素,只是查看 this.top = function () { return items[items.length - 1]; } //isEmpty返回栈是否为空 this.isEmpty = function () { return items.length == 0; } //size方法返回栈的大小 this.size = function () { return items.length; } //clear方法清空栈 this.clear = function () { items = []; } } 多说几句怎么样，是不是感觉很简单？或者说有疑问，既然数组都能直接实现这些功能为什么还要使用栈这种东西？其实这样的实现不过是对数组进行了一层封装而已，栈能做的事情数组同样可以做，但是针对某些问题，栈这种数据结构更符合数据的使用特点。封装是为了隐藏实现细节，站在栈的肩膀上思考问题要比站在数组的肩膀上思考更方便，在后面的使用实例中将会有所体会。 带有min函数的栈注意：仅限于能够比较大小的数据。如果是对象，可以自定义比较规则。 代码function MinStack() { var data_stack = new Stack(); var min_stack = new Stack(); //push的时候，两个栈都要操作 this.push = function (item) { data_stack.push(item); if (min_stack.isEmpty() || item &lt; min_stack.top()) { min_stack.push(item) } else { min_stack.push(min_stack.top()); //与数据栈元素数量保持一致 } } //pop的时候，两个栈都要pop this.pop = function () { data_stack.pop(); min_stack.pop(); } //min函数，直接取最小值栈的栈顶元素 this.min = function () { return min_stack.top(); } //其他函数直接调用原栈的对应函数 } //测试代码 minstack = new MinStack(); minstack.push(3); minstack.push(6); minstack.push(8); console.log(minstack.min()); //打印结果：3 minstack.push(2); minstack.push(4); console.log(minstack.min()); //打印结果：2 这是我做过的一道题目，看到这个题目我的第一反应是加一个字段直接记录最小值，但稍加思考就知道这样肯定不行，因为栈是由出栈这个操作的，如果说记录的那个最小值在栈中出栈了，但是记录的这个最小值不会改变，这就导致使用min函数获得的这个最小值其实是不存在的。如果使用两个栈，一个是数据栈，记录栈中的所有数据，而另一个是最小值栈，记录最小值。注意：两个栈中的元素个数是一致的，在压栈的时候，先把新数据压入数据栈中，如果压入的数据比最小值栈中栈顶的数据小则把新数据压入最小值栈中，否则取最小值栈中的栈顶元素压入最小值栈中，保持两个栈中元素数量的相同，在出栈的时候，如果出栈的元素是最小值，那么对应在最小值栈中对应位置的最小值也将出栈，不存在使用一个变量记录最小值而导致的问题。 使用实例(简单的算法实现)判断字符串中的括号是否合法匹配function isRightfulBrackets(string) { var stack = new Stack(); var str = string.slice(); for (let i = 0; i &lt; str.length; i++) { var char = str.charAt(i); if (char == &quot;(&quot;) { stack.push(char); //将左括号压入栈中 } if (char == &quot;)&quot;) { if (stack.isEmpty()) { return false; //如果为空说明缺少左括号，不合法 } else { stack.pop(); //将左括号弹出栈 } } } return stack.size() == 0; //如果stack大小为0，说明左右括号都匹配；相反，则说明左括号有多余，不合法 } //测试代码 console.log(isRightfulBrackets(&quot;sdf(ds(ew(we)rw)rwqq)qwewe&quot;)); // 打印结果：true console.log(isRightfulBrackets(&quot;(sd(qwqw)sd(sd))&quot;)); // 打印结果：true console.log(isRightfulBrackets(&quot;()()sd()(sd()fw))(&quot;)); // false 计算逆波兰式（后缀表达式）的结果function reversePolishExp(exp_array) { var stack = new Stack(); for (let i = 0; i &lt; exp_array.length; i++) { var char = exp_array[i]; if ([&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;].indexOf(char) &gt;= 0) { var num1 = stack.pop(); var num2 = stack.pop(); var expString = num2 + char + num1; var res = parseInt(eval(expString)); //将计算结果压入栈中 stack.push(res.toString()); } else { stack.push(char); } } // 表达式如果是正确的,最终,栈⾥里里还有⼀一个元素,且正是表达式的计算结果 return stack.pop(); } //测试代码 var exp_1 = [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]; // (4 + (13 / 5)) = 6 var exp_2 = [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]; //((10 * (6 / ((9 + 3) * -11))) + 17) + 5 console.log(reversePolishExp(exp_1)); // 打印结果：6 console.log(reversePolishExp(exp_2)); // 打印结果：22 中序表达式转后续表达式//定义运算符优先级 var priority_map = { &quot;+&quot;: 1, &quot;-&quot;: 1, &quot;*&quot;: 2, &quot;/&quot;: 2 }; function infix_exp_2_postfix_exp(exp) { var stack = new Stack(); var postfix_lst = []; for (var i = 0; i &lt; exp.length; i++) { var item = exp[i]; if (!isNaN(item)) { // 如果是数字,直接放⼊到postfix_lst中 postfix_lst.push(item); } else if (item == &quot;(&quot;) { // 将左括号压入栈中 stack.push(item); } else if (item == &quot;)&quot;) { // 遇到右括号,把栈顶元素弹出放⼊到postfix_lst中,直到遇到左括号 while (stack.top() != &quot;(&quot;) { postfix_lst.push(stack.pop()); } stack.pop(); // 左括号出栈 } else { // 遇到运算符,把栈顶的运算符弹出,直到栈顶的运算符优先级小于当前运算符 while (!stack.isEmpty() &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;].indexOf(stack.top()) &gt;= 0 &amp;&amp; priority_map[stack.top()] &gt;= priority_map[item]) { // 把弹出的运算符加⼊到postfix_lst postfix_lst.push(stack.pop()); } // 当前的运算符⼊入栈 stack.push(item); } } // for循环结束后, 栈里可能还有元素,都弹出放入到postfix_lst中 while (!stack.isEmpty()) { postfix_lst.push(stack.pop()); } return postfix_lst; } //测试代码 // 12+3 console.log(infix_exp_2_postfix_exp([&quot;12&quot;, &quot;+&quot;, &quot;3&quot;])); // 打印结果：[&quot;12&quot;, &quot;3&quot;, &quot;+&quot;] // 2-3+2 console.log(infix_exp_2_postfix_exp([&quot;2&quot;, &quot;-&quot;, &quot;3&quot;, &quot;+&quot;, &quot;2&quot;])); // 打印结果：[&quot;2&quot;, &quot;3&quot;, &quot;-&quot;, &quot;2&quot;, &quot;+&quot;] // (1+(4+5+3)-3)+(9+8) var exp = [&quot;(&quot;, &quot;1&quot;, &quot;+&quot;, &quot;(&quot;, &quot;4&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;, &quot;3&quot;, &quot;)&quot;, &quot;-&quot;, &quot;3&quot;, &quot;)&quot;, &quot;+&quot;, &quot;(&quot;, &quot;9&quot;, &quot;+&quot;, &quot;8&quot;, &quot;)&quot;]; console.log(infix_exp_2_postfix_exp(exp)); // 打印结果： [&quot;1&quot;, &quot;4&quot;, &quot;5&quot;, &quot;+&quot;, &quot;3&quot;, &quot;+&quot;, &quot;+&quot;, &quot;3&quot;, &quot;-&quot;, &quot;9&quot;, &quot;8&quot;, &quot;+&quot;, &quot;+&quot;] // (1+(4+5+3)/4-3)+(6+8)*3 var exp = [&apos;(&apos;, &apos;1&apos;, &apos;+&apos;, &apos;(&apos;, &apos;4&apos;, &apos;+&apos;, &apos;5&apos;, &apos;+&apos;, &apos;3&apos;, &apos;)&apos;, &apos;/&apos;, &apos;4&apos;, &apos;-&apos;, &apos;3&apos;, &apos;)&apos;, &apos;+&apos;, &apos;(&apos;, &apos;6&apos;, &apos;+&apos;, &apos;8&apos;, &apos;)&apos;,&apos;*&apos;, &apos;3&apos;]; console.log(infix_exp_2_postfix_exp(exp)); // 打印结果：[&quot;1&quot;, &quot;4&quot;, &quot;5&quot;, &quot;+&quot;, &quot;3&quot;, &quot;+&quot;, &quot;4&quot;, &quot;/&quot;, &quot;+&quot;, &quot;3&quot;, &quot;-&quot;, &quot;6&quot;, &quot;8&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;, &quot;+&quot;] console.log(infix_exp_2_postfix_exp([&quot;12&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;, &quot;5&quot;])); // 打印结果：[&quot;12&quot;, &quot;3&quot;, &quot;5&quot;, &quot;*&quot;, &quot;+&quot;] console.log(infix_exp_2_postfix_exp([&quot;12&quot;, &quot;*&quot;, &quot;3&quot;, &quot;+&quot;, &quot;5&quot;])); // 打印结果：[&quot;12&quot;, &quot;3&quot;, &quot;*&quot;, &quot;5&quot;, &quot;+&quot;]","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://eviler.top/tags/数据结构/"},{"name":"javascript","slug":"javascript","permalink":"https://eviler.top/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"https://eviler.top/tags/算法/"}]},{"title":"Javascript中的正则表达式详解以及一些常用表单验证实例","date":"2018-11-28T12:06:49.000Z","path":"articles/javascript-regexp/","text":"正则表达式是一个非常好用并且经常会用到的工具，然而学习了好长时间javascript却没有好好地学习一下正则表达式，现在系统地学习一下，并且学以致用，自己写几个用于表单数据格式验证的实例。 什么是正则表达式正则表达式（英语：Regular Expression，再代码证常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 正则表达式是有一个字符序列形成的搜索模式。 当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。 正则表达式可以是一个简单的字符，或一个更复杂的模式。 正则表达式可用于所有文本搜索和文本替换的操作。 语法var patt = new Reg(pattern, modifiers); 或者更简单的方式： var patt=/pattern/modifiers pattern(模式)描述了表达式的模式 modifiers(修饰符)用于指定全局匹配、区分大小写的匹配和多行匹配注意:当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。比如，以下是等价的： var re = new RegExp(“\\w+”); var re = /\\w+/;RegExp修饰符修饰符用于执行不区分大小写和全文的搜索。 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配 RegExp模式方括号方括号用于查找某个范围的字符： 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 ( red &#124; blue &#124; green ) 查找任何指定的选项。 元字符元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \\w 查找单词字符。 \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NULL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 什么是单词边界？找到一个博客，上面有讲解：正则表达式单词边界和非单词边界 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 例如，/a+/ 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。 n* 匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。 n? 匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 “angel” 中的 “el”，”angle” 中的 “le”。 n{X} 匹配包含 X 个 n 的序列的字符串。例如，/a{2}/ 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。 n{X,} X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a{2,}/ 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。 n{X,Y} X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。 例如，/a{1,3}/ 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。捕获性分组 ?:n 匹配任何其后紧接指定字符串 n 的字符串。非捕获性分组 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 捕获性分组，非捕获性分组，前瞻，后瞻 RegExp 对象方法test方法检索字符串中指定的值。返回 true 或 false。语法：RegExpObject.test(string)参数：string：必须。要检测的字符串。实例： var str=&quot;Hello world!&quot;; //查找&quot;Hello&quot; var patt=/Hello/g; var result=patt.test(str); document.write(&quot;返回值: &quot; + result); //查找 &quot;Runoob&quot; patt=/Runoob/g; result=patt.test(str); document.write(&quot;&lt;br&gt;返回值: &quot; + result); 实例输出结果： 返回值: true 返回值: false exec方法用于检索字符串中的正则表达式的匹配，如果字符串中有匹配的值返回该匹配值，否则返回 null。语法：RegExpObject.exec(string)参数：string：必须。要检测的字符串。实例： var str=&quot;Hello world!&quot;; //查找&quot;Hello&quot; var patt=/Hello/g; var result=patt.exec(str); document.write(&quot;返回值: &quot; + result); //查找 &quot;RUNOOB&quot; patt=/RUNOOB/g; result=patt.exec(str); document.write(&quot;&lt;br&gt;返回值: &quot; + result); 实例输出结果： 返回值: Hello 返回值: false 说明：exec() 方法的功能非常强大，它是一个通用的方法，而且使用起来也比 test() 方法以及支持正则表达式的 String 对象的方法更为复杂。如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。比如以下的实例： var str = &quot;Visit W3School&quot;; var patt = new RegExp(&quot;W3School&quot;,&quot;g&quot;); var result; while ((result = patt.exec(str)) != null) { document.write(result); document.write(&quot;&lt;br /&gt;&quot;); document.write(patt.lastIndex); } 输出： W3School 14 compile方法compile() 方法用于在脚本执行过程中编译正则表达式。compile() 方法也可用于改变和重新编译正则表达式。语法：RegExpObject.compile(regexp,modifier)参数：regexp：正则表达式；modifier：规定匹配的类型实例：在字符串中全局搜索 “man”，并用 “person” 替换。然后通过 compile() 方法，改变正则表达式，用 “person” 替换 “man” 或 “woman” var str=&quot;Every man in the world! Every woman on earth!&quot;; patt=/man/g; str2=str.replace(patt,&quot;person&quot;); document.write(str2+&quot;&lt;br /&gt;&quot;); patt=/(wo)?man/g; patt.compile(patt); str2=str.replace(patt,&quot;person&quot;); document.write(str2); 实例输出： Every person in the world! Every woperson on earth! Every person in the world! Every person on earth! toString方法返回正则表达式的字符串值语法：RegExpObject.toString()实例： var patt = new RegExp(&quot;Eviler&quot;, &quot;g&quot;); var res = patt.toString(); document.weite(res); 实例输出： /Eviler/g RegExp 对象属性 属性 描述 global 判断是否设置了 “g” 修饰符 ignoreCase 判断是否设置了 “i” 修饰符 multiline 判断是否设置了 “m” 修饰符 constructor 返回一个函数，该函数是一个创建 RegExp 对象的原型。 lastIndex 用于规定下次匹配的起始位置 source 返回正则表达式的匹配模式 注意： lastIndex 属性只有设置标志 g 才能使用。上次匹配的结果是由方法 RegExp.exec() 和 RegExp.test() 找到的，它们都以 lastIndex 属性所指的位置作为下次检索的起始点。这样，就可以通过反复调用这两个方法来遍历一个字符串中的所有匹配文本。 该属性是可读可写的。只要目标字符串的下一次搜索开始，就可以对它进行设置。当方法 exec() 或 test() 再也找不到可以匹配的文本时，它们会自动把 lastIndex 属性重置为 0。 支持正则表达式的String对象的方法search方法search方法用来检索与正则表达式相匹配的值实例：查找”Eviler”: var str=&quot;Visit Eviler&apos;s Blog!&quot;; var n=str.search(&quot;Eviler&quot;); document.write(n); 实例输出： 6 match方法match方法用来找到一个或多个正则表达式的匹配实例： var str=&quot;The rain in SPAIN stays mainly in the plain&quot;; var n=str.match(/ain/g); document.write(n); 实例输出： ain,ain,ain 注意：match() 方法将检索字符串 String Object，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。 replace方法replace方法用来替换与正则表达式匹配的子串实例： var str=&quot;There are some men and women!Men and Women!&quot;; document.write(&quot;原字符串：&quot;+ &quot;&lt;br /&gt;&quot;+str+ &quot;&lt;br /&gt;&quot;); var m=str.replace(/men/i,&quot;boys&quot;); document.write(&quot;将第一个&apos;men&apos;(不区分大小写)替换成&apos;boys&apos;：&quot;+ &quot;&lt;br /&gt;&quot;+m + &quot;&lt;br /&gt;&quot;); var n=str.replace(/women/gi,&quot;girls&quot;); document.write(&quot;将所有&apos;women&apos;(不区分大小写)替换成&apos;girls&apos;：&quot;+ &quot;&lt;br /&gt;&quot;+n); 实例输出： 原字符串： There are some men and women!Men and Women! 将第一个&apos;men&apos;(不区分大小写)替换成&apos;boys&apos;： There are some boys and women!Men and Women! 将所有&apos;women&apos;(不区分大小写)替换成&apos;girls&apos;： There are some men and girls!Men and girls! split方法split方法用来把字符串分割为字符串数组实例：获取一段英文句子中的单词 var str=&quot;This is my personal page&quot;; document.write(str.split(&apos; &apos;)); 实例输出： This,is,my,personal,page 综合实例&amp;常用表单数据格式验证代码//验证是否位合法的邮箱地址 function isEmail(str) { var reg = /^\\w+@[a-zA-Z0-9]{2,10}(?:\\.[a-z]{2,4}){1,3}$/; return reg.test(str); } //验证是否是合法的手机号码 function isPhoneNumber(str) { var reg = /^1[34578]\\d{9}$/; return reg.test(str); } //验证中国邮政编码,开头不能为0，共6位 function isZipCode(str) { var reg = /^[1-9]\\d{5}$/; return reg.test(str); } //验证中文姓名，2-5个汉字 function isChainName(str) { var reg = /^[\\u4E00-\\u9FA5]{2,5}$/; return reg.test(str); } //验证是否为正整数 function isNumber(str) { if (!str) { return false; } var reg = /\\D/; return !reg.test(str); } 试一试邮&#12288;&#12288;箱：手机号码：邮政编码：中文姓名：正整数验证：验证 function submit() { var input1 = document.getElementById(\"input1\"); var value1 = input1.value; input1.parentNode.querySelector(\".warning\").innerHTML = isEmail(value1) var input2 = document.getElementById(\"input2\"); var value2 = input2.value; input2.parentNode.querySelector(\".warning\").innerHTML = isPhoneNumber(value2) var input3 = document.getElementById(\"input3\"); var value3 = input3.value; input3.parentNode.querySelector(\".warning\").innerHTML = isZipCode(value3) var input4 = document.getElementById(\"input4\"); var value4 = input4.value; input4.parentNode.querySelector(\".warning\").innerHTML = isChainName(value4) var input5 = document.getElementById(\"input5\"); var value5 = input5.value; input5.parentNode.querySelector(\".warning\").innerHTML = isNumber(value5) } //验证是否位合法的邮箱地址 function isEmail(str) { var reg = /^\\w+@[a-zA-Z0-9]{2,10}(?:\\.[a-z]{2,4}){1,3}$/; return reg.test(str); } //验证是否是合法的手机号码 function isPhoneNumber(str) { var reg = /^1[34578]\\d{9}$/; return reg.test(str); } //验证中国邮政编码,开头不能为0，共6位 function isZipCode(str) { var reg = /^[1-9]\\d{5}$/; return reg.test(str); } //验证中文姓名，2-5个汉字 function isChainName(str) { var reg = /^[\\u4E00-\\u9FA5]{2,5}$/; return reg.test(str); } //验证是否为正整数 function isNumber(str) { if (!str) { return false; } var reg = /\\D/; return !reg.test(str); }","tags":[{"name":"javascript","slug":"javascript","permalink":"https://eviler.top/tags/javascript/"}]},{"title":"Html元素类型：块级元素、行内元素（内联元素）和行内块级元素","date":"2018-11-21T14:28:10.000Z","path":"articles/html-element-type/","text":"html中的标签元素大体被分为三种不同的类型：块级元素、内联元素(又叫行内元素)和内联块级元素。事实上，我以前用的时候只是建立在对它们的初步了解之上，可能有时候的使用方法并不正确，这次我需要在实验的基础上去更加深入地认识它们，并且进行一些简单的对比，了解它们之间的差别与联系，从而能够正确地使用它们。 块级元素特点 每个元素都从新的一行开始，其后的元素另起一行，即使设置宽度为0，只要有高度，都会独占一行 元素的高度、宽度、行高以及顶部和内外边距（上下左右）都可设置 元素如果不设置宽度，则是它本身符容器的100%（和父元素的宽度一致） 常见的块状元素div、p、h1~h6、ul、ol、dl、li、dd、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer等 常见的块状元素 内联元素（行内元素）特点 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 常见的内联元素span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block） 常见的内联元素 内联块级元素（行内块级元素）特点(同时具有块级元素、内联元素的特点) 和其他元素都在一行上； 元素的高度、宽度、行高以及内外边距（上下左右）都可设置 常见的内联块状元素input、textarea、select、button 常见的内联块级元素 三种元素类型样式对比代码&lt;hr&gt; &lt;div style=&quot;width:200px;height:100px;background:red&quot;&gt;我是第一个div，宽度200px，高度100px，背景色为红色&lt;/div&gt; &lt;div style=&quot;width:200px;height:100px;background:blue&quot;&gt;我是第二个div，宽度200px，高度100px，背景色为蓝色&lt;/div&gt; &lt;hr&gt; &lt;span style=&quot;width:200px;height:100px;background:red&quot;&gt;我是第一个span，宽度200px，高度100px，背景色为红色&lt;/span&gt; &lt;span style=&quot;width:200px;height:100px;background:blue&quot;&gt;我是第二个span，宽度200px，高度100px，背景色为蓝色&lt;/span&gt; &lt;hr&gt; &lt;button style=&quot;width:200px;height:100px;background:red&quot;&gt;我是第一个button，宽度200px，高度100px，背景色为红色&lt;/button&gt; &lt;button style=&quot;width:200px;height:100px;background:blue&quot;&gt;我是第二个button，宽度200px，高度100px，背景色为蓝色&lt;/button&gt; &lt;hr&gt; 效果我是第一个div，宽度200px，高度100px，背景色为红色我是第二个div，宽度200px，高度100px，背景色为蓝色我是第一个span，宽度200px，高度100px，背景色为红色我是第二个span，宽度200px，高度100px，背景色为蓝色我是第一个button，宽度200px，高度100px，背景色为红色我是第二个button，宽度200px，高度100px，背景色为蓝色 实质上，虽然对span这个内联元素设置了宽度和高度，然而并没有起到效果。 总结三种元素类型的特点决定了它的显示方式和一些属性的可设置性，我们再做网页开发的时候一定要用好它们，有时候如果元素标签本身的类型不能满足我们布局需要的时候，可以使用样式设置对它们进行类型修改变换。 设置display:block；可以将元素转换块级元素； 设置display:inline；可以将块状元素转换为内联元素； 设置display:inline-block；可以将元素设置为内联块级元素。","tags":[{"name":"html","slug":"html","permalink":"https://eviler.top/tags/html/"},{"name":"css","slug":"css","permalink":"https://eviler.top/tags/css/"}]},{"title":"Html中的表格","date":"2018-11-16T07:59:06.000Z","path":"articles/html-table/","text":"Html中的表格是我们经常要用到的，也就是table标签，但是在我们使用table标签的时候是否忽略它本身的一些属性呢？对于我来说是的，所以回头看的同时再记一记笔记，加深印象。 正常表格效果表格标题姓名性别张三男李四男 代码&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 跨行和跨列的表格效果横跨两列的单元格姓名电话张三555 77 556555 77 557李四555 77 558555 77 559 横跨两行的单元格姓名张三电话555 77 556555 77 557 代码&lt;table&gt; &lt;caption&gt;横跨两列的单元格&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;电话&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;555 77 556&lt;/td&gt; &lt;td&gt;555 77 557&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;555 77 558&lt;/td&gt; &lt;td&gt;555 77 559&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table&gt; &lt;caption&gt;横跨两行的单元格&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;td&gt;张三&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;电话&lt;/th&gt; &lt;td&gt;555 77 556&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;555 77 557&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 单元格边距和格间距(Cell padding &amp; Cell spacing)这两个单元格属性我采用对比的方式来说明 效果截图 表格效果截图1 代码&lt;div&gt; &lt;table border=&quot;1&quot;&gt; &lt;caption&gt;无格边距和格间距&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;table cellpadding=&quot;10&quot; border=&quot;1&quot;&gt; &lt;caption&gt;有格边距，无格间距&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;table cellspacing=&quot;15&quot; border=&quot;1&quot;&gt; &lt;caption&gt;无格边距，有格间距&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;table cellpadding=&quot;10&quot; cellspacing=&quot;15&quot; border=&quot;1&quot;&gt; &lt;caption&gt;有格边距和格间距&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; 我想，效果图一做对比很自然地就明白cellpadding和cellspacing的作用以及它们两个的区别了。 框架(frame)属性注释：frame 属性无法在 Internet Explorer 中正确地显示。 效果 表格效果截图2 代码&lt;div&gt; &lt;p&gt;Table with frame=&quot;box&quot;:&lt;/p&gt; &lt;table frame=&quot;box&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;Table with frame=&quot;above&quot;:&lt;/p&gt; &lt;table frame=&quot;above&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;Table with frame=&quot;below&quot;:&lt;/p&gt; &lt;table frame=&quot;below&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;Table with frame=&quot;hsides&quot;:&lt;/p&gt; &lt;table frame=&quot;hsides&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;Table with frame=&quot;vsides&quot;:&lt;/p&gt; &lt;table frame=&quot;vsides&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; 其他还有一些需要注意的： 空单元格：如果想要一个单元格内容为空但是有边框可以将内容设置为no-breaking空格，即 ‘&amp;’+”nbsp”+’;’ ，你们懂得 向表格/表格单元添加背景颜色或背景图像：使用css添加，和设置普通标签背景色和背景图一样","tags":[{"name":"html","slug":"html","permalink":"https://eviler.top/tags/html/"}]},{"title":"Vscode插件livereload配合chrome扩展程序livereload实现网页自动刷新(保存时)","date":"2018-11-15T14:11:40.000Z","path":"articles/plugin-livereload/","text":"前段时间电脑系统坏了，重新装系统后便是繁琐的软件重装了（对于程序猿来说，开发环境才是大事），这不，重装vscode插件livereload时，竟然忘了它怎么用了！！！？于是有要百度一波，但是，查了好几个博客才解决了我的问题，都怪自己记性不好啦。不多说了，步入正题。 第一步，下载并安装vscode插件livereload在vscode中搜索扩展livereload，选择第一个并点击安装，安装完成后点击重新加载 截图1 第二步，启动livereload server同时按ctrl+shift+p,输入框内输入livereload，就会显示LiveReload:Enable/disable server，点一下就会开启这个服务（再点会关闭，所以如果遇到服务没有开启的问题可以再点一下试试）。 第三步，安装谷歌浏览器插件LiveReload谷歌浏览器网上应用商店搜索（科学上网，自行解决/嘿嘿，也可以百度这个扩展程序，很容易找到的）：LiveReload，安装下图中的扩展程序: 截图2 第四步，打开livereload插件设置，启用扩展程序和允许访问文件网站启用此拓展程序，此程序启用后浏览器右上角会多出一个图标： 截图3 开启允许访问文件网站（只有这样它才能检测到文件的更新）： 截图4 第五步，谷歌浏览器开启此服务在浏览器中打开你想要自动刷新的html文档，点击下图的这个图标：如果中间的小圆圈被填充则说明开启成功 截图5 如果点击一下浏览器弹出下面的弹窗则说明Vscode中的 livereload 服务没开启，回头看一看第二步，重新开一下 截图6 第六步，没有了好了，差不多就这么多了， 用了这个插件，就再也不用在每次查看html编写效果时手动刷新页面了，感觉方便清爽多了，祝大家编程开心。","tags":[{"name":"开发技巧","slug":"开发技巧","permalink":"https://eviler.top/tags/开发技巧/"},{"name":"vscode插件","slug":"vscode插件","permalink":"https://eviler.top/tags/vscode插件/"}]},{"title":"Html中的图像映射","date":"2018-11-14T15:31:46.000Z","path":"articles/html-imgareamap/","text":"当我们需要在一张图片上选择一些区域，这些区域能够被用户所点击然后做出一些动作（如跳转到另一个页面）的时候，图象映射便能够很好地完成这项任务。 需要用到的标签 img : 定义图像 map : 定义图像地图 area : 定义图像地图中的可点击区域 创建步骤 使用 img 标签定义图象 &lt;img src=&quot;./eg_planets.jpg&quot; usemap=&quot;#planemap&quot; alt=&quot;Planets&quot;&gt; 使用map标签定义图像地图 &lt;map name=&quot;planetmap&quot; id=&quot;planetmap&quot;&gt; &lt;/map&gt; 注释：img 元素中的 “usemap” 属性引用 map 元素中的 “id” 或 “name” 属性（根据浏览器），所以同时向 map 元素添加了 “id” 和 “name” 属性。 使用area标签定义图像地图中的可点击区域 &lt;area shape=&quot;circle&quot; coords=&quot;180, 139, 14&quot; href=&quot;&quot; target=&quot;_blank&quot; /&gt; &lt;area shape=&quot;circle&quot; coords=&quot;129, 161, 10&quot; href=&quot;&quot; target=&quot;_blank&quot;/&gt; &lt;area shape=&quot;rect&quot; coords=&quot;0, 0, 110, 260&quot; href=&quot;&quot; target=&quot;_blank&quot;/&gt; 将这些area标签放到map标签内 整体代码&lt;img src=&quot;eg_planets.jpg&quot; usemap=&quot;#planetmap&quot; alt=&quot;Planets&quot;&gt; &lt;map name=&quot;planetmap&quot; id=&quot;planetmap&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;180, 139, 14&quot; href=&quot;&quot; target=&quot;_blank&quot; /&gt; &lt;area shape=&quot;circle&quot; coords=&quot;129, 161, 10&quot; href=&quot;&quot; target=&quot;_blank&quot;/&gt; &lt;area shape=&quot;rect&quot; coords=&quot;0, 0, 110, 260&quot; href=&quot;&quot; target=&quot;_blank&quot;/&gt; &lt;/map&gt; 效果点击图片中的星球可在新的标签页打开本页面，这个可根据自己的需求更改图片来自w3school","tags":[{"name":"html","slug":"html","permalink":"https://eviler.top/tags/html/"}]},{"title":"Html格式化标签","date":"2018-11-13T12:49:11.000Z","path":"articles/html-format/","text":"写了快一年的前端，不知道使以前学校html的时候没有注意还是没有用过就把这个东西忽略了，Html自带一些文本格式化标签，可以满足一些日常简单的文本格式化需求。今天回顾html的时候看到了，学习的同时记一下笔记。 文本格式化效果This text is boldThis text is strongThis text is smallThis text is emphasized（强调）This text is italic（斜体）高亮This text containssubscript(下标)This text containssuperscript(上标) 代码&lt;b&gt;This text is bold&lt;/b&gt; &lt;br /&gt; &lt;strong&gt;This text is strong&lt;/strong&gt; &lt;br /&gt; &lt;small&gt;This text is small&lt;/small&gt; &lt;br /&gt; &lt;em&gt;This text is emphasized（强调）&lt;/em&gt; &lt;br /&gt; &lt;i&gt;This text is italic（斜体）&lt;/i&gt; &lt;br /&gt; &lt;mark&gt;高亮&lt;/mark&gt; &lt;br /&gt; This text contains &lt;sub&gt;subscript(下标)&lt;/sub&gt; &lt;br /&gt; This text contains &lt;sup&gt;superscript(上标)&lt;/sup&gt; &lt;br /&gt; 预格式化文本预格式化文本能够将标签内的文本按照自己原来的文本格式显示出来，它保留了空格和换行。 效果注意：这里编辑器将pre标签自带显示为代码，但效果是一样的 这是 预格式文本。 它保留了 空格 和换行。 for i = 1 to 10 print i next i 代码&lt;pre&gt; 这是 预格式文本。 它保留了 空格 和换行。 &lt;/pre&gt; &lt;pre&gt; for i = 1 to 10 print i next i &lt;/pre&gt; “计算机输出”标签效果Computer codeKeyboard inputSample textComputer variable 代码&lt;code&gt;Computer code&lt;/code&gt; &lt;kbd&gt;Keyboard input&lt;/kbd&gt; &lt;samp&gt;Sample text&lt;/samp&gt; &lt;var&gt;Computer variable&lt;/var&gt; 这些标签常用于显示计算机/编程代码code 元素不保留多余的空格和折行kbd 元素定义键盘输入samp 元素定义计算机输出示例var 元素定义数学变量提示：通常，HTML 使用可变的字母尺寸，以及可变的字母间距。在显示计算机代码示例时，并不需要如此。kbd, samp, 以及 code 元素全都支持固定的字母尺寸和间距。 地址地址标签为address，使用此标签可以在Html文件中写地址 效果Written by Eviler.Visit us at:eviler.top 代码&lt;address&gt;Written by &lt;a href=&quot;eviler.top&quot;&gt;Eviler&lt;/a&gt;. Visit us at: eviler.top &lt;/address&gt; 删除字效果和插入字效果效果一打有 二十 十二 件。 代码&lt;p&gt;一打有 &lt;del&gt;二十&lt;/del&gt; &lt;ins&gt;十二&lt;/ins&gt; 件。&lt;/p&gt; 大多数浏览器会改写为删除文本和下划线文本。一些老式的浏览器会把删除文本和下划线文本显示为普通文本。我们也可以通过改变文本标签的样式来达到这种效果: &lt;p&gt;一打有 &lt;i style=&quot;text-decoration: line-through&quot;&gt;二十&lt;/i&gt; &lt;i style=&quot;text-decoration: underline&quot;&gt;十二&lt;/i&gt; 件。 &lt;/p&gt; 或者使用标签s和u： &lt;p&gt;一打有 &lt;s&gt;二十&lt;/s&gt;&lt;u&gt;十二&lt;/u&gt;件。&lt;/p&gt; 文字方向效果Here is some Hebrew text 如果浏览器支持 bi-directional override (bdo)，下一行会从右向左输出 (rtl):Here is some Hebrew text 代码&lt;bdo&gt; Here is some Hebrew text &lt;/bdo&gt; &lt;p&gt; 如果浏览器支持 bi-directional override (bdo)，下一行会从右向左输出 (rtl):&lt;/p&gt; &lt;bdo dir=&quot;rtl&quot;&gt; Here is some Hebrew text &lt;/bdo&gt; 块引用blockquote和q标签以前倒是注意到过，但是后来也没用过，就把它们给忘了 效果这是长的引用： 这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是短的引用：这是短的引用。 代码这是长的引用： &lt;blockquote&gt; 这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。 &lt;/blockquote&gt; 这是短的引用： &lt;q&gt;这是短的引用。&lt;/q&gt; 使用 blockquote 元素的话，浏览器会插入换行和外边距，而 q 元素不会有任何特殊的呈现。","tags":[{"name":"html","slug":"html","permalink":"https://eviler.top/tags/html/"}]},{"title":"AngularJS踩坑之路(四)：商品展示案例","date":"2018-10-15T11:15:31.000Z","path":"articles/angular-case-commodityShow/","text":"今天跟着老师做了一个简单的商品展示案例，综合使用了前几节课所学到的知识，还有一些前几节课没有涉及到的知识，真是新知复习两不误。 商品展示案例展示页面截图 商品展示案例页面截图 功能简述 显示商品列表 可根据商品名称进行搜索 可按商品评价、价格和销量进行排序展示 商品展示案例代码index.html:&lt;html lang=&quot;en&quot; ng-app=&quot;myApp&quot; id=&quot;ng-app&quot;&gt; &lt;head&gt; &lt;title&gt;商品展示&lt;/title&gt; &lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style media=&quot;screen&quot;&gt; body { padding-top: 50px; } &lt;/style&gt; &lt;/head&gt; &lt;body ng-controller=&quot;itemsController&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6 col-sm-6 col-xs-12&quot;&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot; ng-click=&quot;changeOrderKey(&apos;better&apos;)&quot;&gt; 按评价排序 &lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot; ng-click=&quot;changeOrderKey(&apos;price&apos;)&quot;&gt; 按价格排序 &lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot; ng-click=&quot;changeOrderKey(&apos;saled&apos;)&quot;&gt; 按销量排序 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4 col-sm-6 col-xs-12&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;输入商品名称&quot; ng-model=&quot;keyword&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;hr&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-2 col-sm-3 col-xs-4&quot; ng-repeat=&quot;item in items | orderBy:orderByKey:isReverse | filter:results&quot;&gt; &lt;div class=&quot;thumbnall&quot; style=&quot;text-align:center&quot;&gt; &lt;img ng-src=&quot;{{item.img}}&quot; alt=&quot;测试图片&quot;&gt; &lt;div class=&quot;caption&quot;&gt; &lt;h4 ng-bind=&quot;item.name&quot;&gt;&lt;/h4&gt; &lt;h4&gt; &lt;span class=&quot;label label-info&quot;&gt;{{item.price | currency:'￥'}}&lt;/span&gt; &lt;/h4&gt; &lt;h6&gt;已售：{{item.saled}}&lt;/h6&gt; &lt;h6&gt;好评：{{item.better}}&lt;/h6&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.7.0/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/Mock.js/1.0.1-beta3/mock-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; main.js://使用mock进行ajax拦截及数据生成 Mock.mock(&quot;https://eviler.top/qetItems&quot;, { //url随便写，只要与下面$http.get中用到的url对应就行 &apos;items|10&apos;: [{ &apos;id|+1&apos;: 1, &apos;price&apos;: /[1-9]{4}/, &apos;name&apos;: /(iPhone|sansung|BlackBerry|WindowPhone)[0-9]/, &apos;img&apos;: &quot;@DataImage(120x120, phone)&quot;, &apos;saled&apos;: /[1-9]{4}/, &apos;better&apos;: /[1-9]{4}/ }] }); const app = angular.module(&quot;myApp&quot;, []); //$http服务 专门用来发送ajax请求的服务 Angular内置服务 app.controller(&quot;itemsController&quot;, [&quot;$scope&quot;, &quot;$http&quot;, function($scope, $http) { $scope.items = []; $scope.keyword = &quot;&quot;; $scope.orderByKey = &quot;&quot;; $scope.isReverse = false; $scope.changeOrderKey = function(type) { $scope.orderByKey = type }; $scope.results = function(val) { console.log(val); return val.name.indexOf($scope.keyword) != -1; }; $http.get(&quot;https://eviler.top/qetItems&quot;).then(function(res) { $scope.items = res.data.items; console.log($scope.items); }).catch(function(err) { console.log(err); }) }]) 用到的知识 angularJs的一些内置指令 bootstrap的一些CSS样式 mock.js(模拟后端请求，可以生成随机数据)的简单使用 angularJs的$http服务","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://eviler.top/tags/angularJs/"}]},{"title":"AngularJS踩坑之路(三)：过滤器","date":"2018-10-15T01:19:41.000Z","path":"articles/angular-filter/","text":"过滤器是我们开发过程中经常会用到的东西，实际上，我们在开发中所写的格式化数据的一些函数也可以称之为过滤器，在我以前所用的框架中，过滤器都是自己写的，vue的内置过滤器也只有4种过滤器，一般满足不了我们的需求，但是AngularJS的内置过滤器就不一样了，有9种过滤器，基本可以满足我们日常开发所需，如不满足也没关系，因为我们可以自定义过滤器。 过滤器使用效果预览提示：字符’|’称为管道符 货币格式过滤器：currency 未使用过滤器：4999 使用默认过滤器：$4,999.00 使用自定义传参过滤器：￥4,999.00 时间格式过滤器：date 未使用过滤器：1539570721577 使用默认过滤器：Oct 15, 2018 使用自定义传参过滤器：2018-10-15 Monday, 10:32:01 AM 数字格式过滤器：number 未使用过滤器：1234567890 使用默认过滤器：1,234,567,890 使用自定义传参过滤器：1,234,567,890.00 字母格式过滤器：uppercase &amp; lowercase 原字符串：Hello uppercase过滤器：HELLO lowercase过滤器：hello 数组排序过滤器：orderBy原对象数组（未排序）： Apple—7999 Samsung—4998 Huawei—3999 Meizu—1998排序后（根据price进行排序，并且反向排序，即由大到小排序）： Apple—7999 Samsung—4998 Huawei—3999 Meizu—1998 过滤器：limitTo用于数组(最多显示两项，本来有四项)： Apple—7999 Samsung—4998用于字符串： 原字符串：Hello 取前三个字符：Hel 取后三个字符：llo 过滤器：filterfilter根据传入的参数从给定的数组中选择一个子集，并生成一个新数组返回原数据： Apple—7999 Samsung—4998 Meizu—1998 Huawei—3999过滤后(过滤含有字符’i’的项))： Meizu—1998 Huawei—3999注意：此过滤方式不区分字段，即只要单个项中存在所匹配内容（’i’），这个phone就会被匹配 格式化json对象过滤器：json这个就和我们熟悉的JSON.stringify()作用一样 用法：{ { jsonTest | json } }(去掉两个大括号之间的空格) 自定义过滤器上面所讲的几种过滤器都是angular内置的过滤器，提供给的功能有时候只能解决我们的部分需求，这时候就需要我们来使用自定义过滤器了。 原字符串：Hello 使用自定义过滤器myFilter（将字符串字符转化为大写）：HELLO 原数组：[1,2,3,4,5] 使用自定义过滤器arrFilter（每一项值的下标次幂，Math.pow(arr[index],index)）：[1,2,9,64,625] 注意：自定义过滤器必须有返回值 最后再说一下，这些过滤器是可以连用的，怎样使用？用管道符连接即可。 代码为了方便书写，我直接把上面输出结果的代码都写在了这里： &lt;html ng-app=&quot;myApp&quot; id=&quot;ng-app&quot;&gt; &lt;head&gt; &lt;title&gt;Angular&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.3.0-beta.7/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=&quot;myController&quot;&gt; &lt;em&gt;提示：字符&apos;|&apos;称为管道符&lt;/em&gt; &lt;h4&gt;货币格式过滤器：currency&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;未使用过滤器：{{price}}&lt;/li&gt; &lt;li&gt;使用默认过滤器：{{price | currency}}&lt;/li&gt; &lt;li&gt;使用自定义传参过滤器：{{price | currency:'￥'}}&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;时间格式过滤器：date&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;未使用过滤器：{{time}}&lt;/li&gt; &lt;li&gt;使用默认过滤器：{{time | date}}&lt;/li&gt; &lt;li&gt;使用自定义传参过滤器：{{time | date:'yyyy-MM-dd EEEE, hh:mm:ss a'}}&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;数字格式过滤器：number &lt;/h4&gt; &lt;ul&gt; &lt;li&gt;未使用过滤器：{{count}}&lt;/li&gt; &lt;li&gt;使用默认过滤器：{{count | number}}&lt;/li&gt; &lt;li&gt;使用自定义传参过滤器：{{count | number:2}}&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;字母格式过滤器：uppercase &amp; lowercase&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;原字符串：{{'Hello'}}&lt;/li&gt; &lt;li&gt;uppercase过滤器：{{'Hello' | uppercase}}&lt;/li&gt; &lt;li&gt;lowercase过滤器：{{'Hello' | lowercase}}&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;数组排序过滤器：orderBy&lt;/h4&gt; &lt;div&gt; &lt;h5&gt;原对象数组（未排序）：&lt;/h5&gt; &lt;ul&gt; &lt;li &gt; {{phone.name}}---{{phone.price}} &lt;/li&gt; &lt;/ul&gt; &lt;h5&gt;排序后（根据price进行排序，并且反向排序，即由大到小排序）：&lt;/h5&gt; &lt;ul&gt; &lt;li &gt; {{phone.name}}---{{phone.price}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h4&gt;过滤器：limitTo&lt;/h4&gt; &lt;div&gt; &lt;h5&gt;用于数组(最多显示两项，本来有四项)：&lt;/h5&gt; &lt;ul&gt; &lt;li &gt; {{phone.name}}---{{phone.price}} &lt;/li&gt; &lt;/ul&gt; &lt;h5&gt;用于字符串：&lt;/h5&gt; &lt;ul&gt; &lt;li&gt;原字符串：Hello&lt;/li&gt; &lt;li&gt;取前三个字符：{{\"Hello\" | limitTo:3}}&lt;/li&gt; &lt;li&gt;取后三个字符：{{\"Hello\" | limitTo:-3}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h4&gt;过滤器：filter&lt;/h4&gt; &lt;div&gt; &lt;p&gt;filter根据传入的参数从给定的数组中选择一个子集，并生成一个新数组返回&lt;/p&gt; &lt;h5&gt;原数据：&lt;/h5&gt; &lt;ul&gt; &lt;li &gt; {{phone.name}}---{{phone.price}} &lt;/li&gt; &lt;/ul&gt; &lt;h5&gt;过滤后(过滤含有字符&apos;i&apos;的项))：&lt;/h5&gt; &lt;ul&gt; &lt;li &gt; {{phone.name}}---{{phone.price}} &lt;/li&gt; &lt;/ul&gt; &lt;em&gt;注意：此过滤方式不区分字段，即只要单个项中存在所匹配内容（&apos;i&apos;），这个phone就会被匹配&lt;/em&gt; &lt;/div&gt; &lt;h4&gt;格式化json对象过滤器：json&lt;/h4&gt; &lt;div&gt; &lt;p&gt;这个就和我们熟悉的JSON.stringify()作用一样&lt;br&gt; 用法：{ { jsonTest | json } }(去掉两个大括号之间的空格) &lt;/p&gt; &lt;/div&gt; &lt;h4&gt;自定义过滤器&lt;/h4&gt; &lt;div&gt; &lt;p&gt;上面所讲的几种过滤器都是angular内置的过滤器，提供给的功能有时候只能解决我们的部分需求，这时候就需要我们来使用自定义过滤器了。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;原字符串：Hello 使用自定义过滤器myFilter（将字符串字符转化为大写）：{{\"Hello\" | myFilter}} &lt;/li&gt; &lt;li&gt;原数组：{{arr}} 使用自定义过滤器arrFilter（每一项值的下标次幂，Math.pow(arr[index],index)）：{{arr | arrFilter}} &lt;/li&gt; &lt;/ul&gt; &lt;em&gt;注意：自定义过滤器必须有返回值&lt;/em&gt; &lt;/div&gt; &lt;p&gt;最后再说一下，这些过滤器是可以连用的，怎样使用？用管道符连接即可。&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); app.run([&quot;$rootScope&quot;, function($rootScope) {}]); app.controller(&quot;myController&quot;, [&quot;$scope&quot;, function($scope) { $scope.orderKey = &quot;price&quot;; $scope.isOrderReverse = true; $scope.filterKey = &apos;i&apos;; $scope.price = 4999; $scope.time = Date.now(); $scope.count = 1234567890; $scope.phones = [{ name: &quot;Apple&quot;, price: 7999 }, { name: &quot;Samsung&quot;, price: 4998 }, { name: &quot;Meizu&quot;, price: 1998 }, { name: &quot;Huawei&quot;, price: 3999 }]; $scope.arr = [1, 2, 3, 4, 5]; }]); app.filter(&quot;myFilter&quot;, function() { return function(val) { return val.toUpperCase() } }) app.filter(&quot;arrFilter&quot;, function() { return function(val) { return val.map(Math.pow); } }) &lt;/script&gt; &lt;/html&gt;","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://eviler.top/tags/angularJs/"}]},{"title":"AngularJS踩坑之路(二)：控制器","date":"2018-10-14T06:50:09.000Z","path":"articles/angular-controller/","text":"今天学习了一下AngularJS中的控制器，所以这篇主要记录一下AngularJS控制器中的一些知识 概念AngularJS中的控制器是一个函数，用来向视图的作用域中添加额外的功能，我们用它来给作用于对象设置初始状态，并添加自定义行为当我们在页面上创建一个新的控制器时，AngularJS会生产并传递一个新的$scope给这个控制器，可以在这个控制器力初始化$scope。 使用控制器 创建控制器 //创建一个模块，并将控制器声明到改模块上，以避免全局污染 var app = angular.module(&quot;myApp&quot;, []); //使用module实例的controller方法创建控制器，并且将创建控制器生产的$scope注入进来，注入方式有两种，可任选其一 app.controller(&quot;myController&quot;, [&quot;$scope&quot;, function($scope) { $scope.name = &quot;Eviler&quot;; $scope.testFunc = function(){ return &quot;Hello&quot;; } }]); 在html中使用 &lt;!--由于创建了自己的模块，在这里要是有ng-app指定自己的模块--&gt; &lt;html ng-app=&quot;myApp&quot; id=&quot;ng-app&quot;&gt; &lt;!--body中--&gt; &lt;div ng-controller=&quot;myController&quot;&gt;&lt;!--通过ng-controller指令将创建的控制器绑定在元素上--&gt; {{testFunc()}} {{name}}&lt;!--输出testFunc方法和name值--&gt; &lt;/div&gt; 注入形式常见的有两种： app.controller(&quot;myController&quot;, [&quot;$scope&quot;, function($scope) { //内联式注入，推荐 $scope.name = &quot;Eviler&quot;; $scope.testFunc = function(){ return &quot;Hello&quot;; } }]); app.controller(&quot;myController&quot;, function($scope) { //推断式注入 //代码不能进行压缩混淆 $scope.name = &quot;Eviler&quot;; $scope.testFunc = function(){ return &quot;Hello&quot;; } }); 控制器可以将与一个独立试图相关的业务逻辑封装在一个独立的容器中。尽可能地精简控制器时很好的做法控制器并不适合用来执行DOM操作、格式化或数据操作，以及除存储数据模型之外的状态维护操作，它只是试图和$scope之间的桥梁 $scope和$rootScopeAngularJS应用程序含有嵌套作用域，这种嵌套结构和DOM的嵌套结构极为类似；而这种嵌套作用域的顶级作用域便是$rootScope，也就是ng-app指令所在的位置；在AngularJS中，除了隔离作用域外，其他所有的作用于都通过原型继承而来，也就是说他们都可以访问父级作用域。请看以下代码：html: &lt;div ng-controller=&quot;myController&quot;&gt; &lt;hr&gt; {{testFun()}} {{name}} {{age}} {{address}} &lt;h4&gt;子级的address值：{{address}}&lt;/h4&gt; &lt;hr&gt; &lt;div ng-controller=&quot;childController&quot;&gt; {{name}} {{age}} {{address}} &lt;/div&gt; &lt;hr&gt; &lt;div ng-controller=&quot;childController2&quot;&gt; {{name}} {{age}} {{zipCode}} &lt;h4&gt;同级的address值：{{address}}&lt;/h4&gt; &lt;/div&gt; &lt;hr&gt; &lt;/div&gt; javascript: var app = angular.module(&quot;myApp&quot;, []); //创建一个模块 app.run([&quot;$rootScope&quot;, function($rootScope) { $rootScope.name = &quot;Eviler&quot;; $rootScope.testFun = function() { return &quot;hello&quot; } }]); //myController app.controller(&quot;myController&quot;, [&quot;$scope&quot;, function($scope) { $scope.age = 20; }]); //childController app.controller(&quot;childController&quot;, [&quot;$scope&quot;, function($scope) { $scope.address = &quot;BeiJing&quot; }]) //childController2 app.controller(&quot;childController2&quot;, [&quot;$scope&quot;, function($scope) { $scope.zipCode = &quot;1234567&quot; }]) 然后看一下代码的运行结果： hello Eviler 20子级的address值： Eviler 20 Beijing Eviler 20 123456同级的address值： 我们来分析一下：name属性和testFunc方法来自$rootScopeage属性来自myController的$scopeaddress属性来自childController的$scopezipCode属性来自childController2的$scope 在myController作用域中：name、testFunc、age都能被正常访问，而访问不到定义于childController中address属性在childController2作用域中：name、testFunc、zipCode都能被正常访问，而访问不到定义于同级的childController2中的address属性所以说：父级不能使用子级的值，同级的控制器之间也不能相互使用不属于自己的值","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://eviler.top/tags/angularJs/"}]},{"title":"AngularJS踩坑之路(一)：一些有关内置指令的要记","date":"2018-10-13T12:45:10.000Z","path":"articles/angular-directive/","text":"开始入坑angularJs，在此记录一下自己学习过程中的点滴，希望angular大哥能够友好对待小弟，我的学习地址：网易云云课堂，本文章记录一些我觉得需要记录的知识点和注意事项。 表达式注意事项 不能使用任何流程控制语句(if/else) 可以使用过滤器或过滤器链（虽然还不知道怎么使用emmmm） ng-switch指令&lt;div&gt; &lt;select ng-model=&quot;selectItem&quot;&gt; &lt;option value=&quot;java&quot;&gt;java&lt;/option&gt; &lt;option value=&quot;php&quot;&gt;php&lt;/option&gt; &lt;/select&gt; &lt;ul ng-switch=&quot;selectItem&quot;&gt; &lt;li ng-switch-when=&quot;java&quot;&gt;选择了Java&lt;/li&gt; &lt;li ng-switch-when=&quot;php&quot;&gt;选择了Php&lt;/li&gt; &lt;li ng-switch-default&gt;什么都没选&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ng-repeat指令&lt;div ng-init=&quot;arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&quot;&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;x in arr&quot;&gt;{{x}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 注意：下面的使用方法会使angular抛出异常 &lt;div ng-init=&quot;arr2=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;b&apos;]&quot;&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;m in arr2&quot;&gt;{{m}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 我们注意到，上面的arr2中有两个相同的字符’b’,angular再便利时需要一个唯一值可以与生成的dom绑定，以便追踪，而在指定的组中出现了相同的值’b’，此时需要track by来为angular确定一个唯一值，将上面的代码改为如下即可： &lt;div ng-init=&quot;arr2=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;b&apos;]&quot;&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;m in arr2 track by $index&quot;&gt;{{m}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 我在想，如果为了避免这种错误再次发生，我们是否可以每次使用ng-repeat指令都使用track by $index呢？我觉得没问题=_=使用过vue的人就会发现，我们使用v-for时，一般都是这种格式: &lt;li v-for=&quot;(item, index) in itenList&quot; :key=&quot;index&quot;&gt;&lt;/li&gt; 我在使用过程中发现，如果不绑定key，编辑器会发出警告信息（可能是vscode插件起的作用吧，不做追究了）angular的ng-repeat何尝不这样做呢，有利无害有木有（按照我的经验和我现在的学习进度来看）。注意：上面的话我得回收一下，因为学完这个的第二天，我又学习了过滤器，然后才发现用过滤器的时候不能使用track by，哈哈哈，打脸啪-啪-啪，左右左右BABA 还有需要注意的地方就是有关’$’操作符，按照我的理解：$index 返回数组下标$first 返回布尔值：是否为数组第一项$last 返回布尔值：是否为数组最后项 ng-class指令看看下面的代码： &lt;div ng-init=&quot;c1=&apos;box1&apos;;bol=true;isC1=true;isC2=true;isC3=false&quot;&gt; &lt;div class=&quot;box&quot; ng-class=&quot;c1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot; ng-class=&quot;{true:&apos;box2&apos;,false:&apos;box3&apos;}[bol]&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot; ng-class=&quot;{&apos;box1&apos;:isC1,&apos;box2&apos;:isC2,&apos;box3&apos;:isC3}&quot;&gt;&lt;/div&gt; &lt;/div&gt; 其中box、box1、box2、box3为样式类名这段代码的效果是：里层的三个div绑定的class分别为（box1）、（box2）和（box1、box2）,这是dom绑定class的三种方式，我们注意到，第一种绑定方式先把类名box1赋值给c1，然后再把c1绑定在指令ng-class，这样是不是显得麻烦了？为何不直接使用下面的代码进行绑定呢： &lt;div class=&quot;box&quot; ng-class=&quot;box1&quot;&gt;&lt;/div&gt; 我试了一下，这样绑定是没有效果的，也就是没有绑定成功，但如果像下面这样使用，就可以绑定成功（box外面加一层单引号）： &lt;div class=&quot;box&quot; ng-class=&quot;&apos;box1&apos;&quot;&gt;&lt;/div&gt;","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://eviler.top/tags/angularJs/"}]}]