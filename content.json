[{"title":"使用js实现的栈以及使用栈实现的几个简单算法","date":"2019-01-19T02:20:34.000Z","path":"articles/data-structure-algorithm-stack/","text":"使用javascript语言实现栈这个数据结构，并且实现几个使用栈来实现的算法。 栈的定义栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。（百度百科） 栈的工作特点后进先出(Last In First Out) 栈的工作特点图解(图片来自互联网) 栈的实现栈的数据存储可以使用数组或者链表做基础，链表也是一种数据结构，后面会单独讲解，所以我使用数组作为基础来实现栈栈通常有以下几个方法 push：添加一个元素到栈顶 pop：弹出一个栈顶元素 top：返回栈顶元素 isEmpty：判断栈是否为空 size：返回栈里元素的个数 clear：清空栈代码实现function Stack() { var items = []; //使用数组存储数据 //push方法向栈里压入一个元素 this.push = function (item) { items.push(item); } //pop方法把栈顶的元素弹出 this.pop = function () { return items.pop(); } //top方法返回栈顶元素,只是查看 this.top = function () { return items[items.length - 1]; } //isEmpty返回栈是否为空 this.isEmpty = function () { return items.length == 0; } //size方法返回栈的大小 this.size = function () { return items.length; } //clear方法清空栈 this.clear = function () { items = []; } } 多说几句怎么样，是不是感觉很简单？或者说有疑问，既然数组都能直接实现这些功能为什么还要使用栈这种东西？其实这样的实现不过是对数组进行了一层封装而已，栈能做的事情数组同样可以做，但是针对某些问题，栈这种数据结构更符合数据的使用特点。封装是为了隐藏实现细节，站在栈的肩膀上思考问题要比站在数组的肩膀上思考更方便，在后面的使用实例中将会有所体会。 带有min函数的栈注意：仅限于能够比较大小的数据。如果是对象，可以自定义比较规则。 代码function MinStack() { var data_stack = new Stack(); var min_stack = new Stack(); //push的时候，两个栈都要操作 this.push = function (item) { data_stack.push(item); if (min_stack.isEmpty() || item &lt; min_stack.top()) { min_stack.push(item) } else { min_stack.push(min_stack.top()); //与数据栈元素数量保持一致 } } //pop的时候，两个栈都要pop this.pop = function () { data_stack.pop(); min_stack.pop(); } //min函数，直接取最小值栈的栈顶元素 this.min = function () { return min_stack.top(); } //其他函数直接调用原栈的对应函数 } //测试代码 minstack = new MinStack(); minstack.push(3); minstack.push(6); minstack.push(8); console.log(minstack.min()); //打印结果：3 minstack.push(2); minstack.push(4); console.log(minstack.min()); //打印结果：2 这是我做过的一道题目，看到这个题目我的第一反应是加一个字段直接记录最小值，但稍加思考就知道这样肯定不行，因为栈是由出栈这个操作的，如果说记录的那个最小值在栈中出栈了，但是记录的这个最小值不会改变，这就导致使用min函数获得的这个最小值其实是不存在的。如果使用两个栈，一个是数据栈，记录栈中的所有数据，而另一个是最小值栈，记录最小值。注意：两个栈中的元素个数是一致的，在压栈的时候，先把新数据压入数据栈中，如果压入的数据比最小值栈中栈顶的数据小则把新数据压入最小值栈中，否则取最小值栈中的栈顶元素压入最小值栈中，保持两个栈中元素数量的相同，在出栈的时候，如果出栈的元素是最小值，那么对应在最小值栈中对应位置的最小值也将出栈，不存在使用一个变量记录最小值而导致的问题。 使用实例(简单的算法实现)判断字符串中的括号是否合法匹配function isRightfulBrackets(string) { var stack = new Stack(); var str = string.slice(); for (let i = 0; i &lt; str.length; i++) { var char = str.charAt(i); if (char == &quot;(&quot;) { stack.push(char); //将左括号压入栈中 } if (char == &quot;)&quot;) { if (stack.isEmpty()) { return false; //如果为空说明缺少左括号，不合法 } else { stack.pop(); //将左括号弹出栈 } } } return stack.size() == 0; //如果stack大小为0，说明左右括号都匹配；相反，则说明左括号有多余，不合法 } //测试代码 console.log(isRightfulBrackets(&quot;sdf(ds(ew(we)rw)rwqq)qwewe&quot;)); // 打印结果：true console.log(isRightfulBrackets(&quot;(sd(qwqw)sd(sd))&quot;)); // 打印结果：true console.log(isRightfulBrackets(&quot;()()sd()(sd()fw))(&quot;)); // false 计算逆波兰式（后缀表达式）的结果function reversePolishExp(exp_array) { var stack = new Stack(); for (let i = 0; i &lt; exp_array.length; i++) { var char = exp_array[i]; if ([&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;].indexOf(char) &gt;= 0) { var num1 = stack.pop(); var num2 = stack.pop(); var expString = num2 + char + num1; var res = parseInt(eval(expString)); //将计算结果压入栈中 stack.push(res.toString()); } else { stack.push(char); } } // 表达式如果是正确的,最终,栈⾥里里还有⼀一个元素,且正是表达式的计算结果 return stack.pop(); } //测试代码 var exp_1 = [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]; // (4 + (13 / 5)) = 6 var exp_2 = [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]; //((10 * (6 / ((9 + 3) * -11))) + 17) + 5 console.log(reversePolishExp(exp_1)); // 打印结果：6 console.log(reversePolishExp(exp_2)); // 打印结果：22 中序表达式转后续表达式//定义运算符优先级 var priority_map = { &quot;+&quot;: 1, &quot;-&quot;: 1, &quot;*&quot;: 2, &quot;/&quot;: 2 }; function infix_exp_2_postfix_exp(exp) { var stack = new Stack(); var postfix_lst = []; for (var i = 0; i &lt; exp.length; i++) { var item = exp[i]; if (!isNaN(item)) { // 如果是数字,直接放⼊到postfix_lst中 postfix_lst.push(item); } else if (item == &quot;(&quot;) { // 将左括号压入栈中 stack.push(item); } else if (item == &quot;)&quot;) { // 遇到右括号,把栈顶元素弹出放⼊到postfix_lst中,直到遇到左括号 while (stack.top() != &quot;(&quot;) { postfix_lst.push(stack.pop()); } stack.pop(); // 左括号出栈 } else { // 遇到运算符,把栈顶的运算符弹出,直到栈顶的运算符优先级小于当前运算符 while (!stack.isEmpty() &amp;&amp; [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;].indexOf(stack.top()) &gt;= 0 &amp;&amp; priority_map[stack.top()] &gt;= priority_map[item]) { // 把弹出的运算符加⼊到postfix_lst postfix_lst.push(stack.pop()); } // 当前的运算符⼊入栈 stack.push(item); } } // for循环结束后, 栈里可能还有元素,都弹出放入到postfix_lst中 while (!stack.isEmpty()) { postfix_lst.push(stack.pop()); } return postfix_lst; } //测试代码 // 12+3 console.log(infix_exp_2_postfix_exp([&quot;12&quot;, &quot;+&quot;, &quot;3&quot;])); // 打印结果：[&quot;12&quot;, &quot;3&quot;, &quot;+&quot;] // 2-3+2 console.log(infix_exp_2_postfix_exp([&quot;2&quot;, &quot;-&quot;, &quot;3&quot;, &quot;+&quot;, &quot;2&quot;])); // 打印结果：[&quot;2&quot;, &quot;3&quot;, &quot;-&quot;, &quot;2&quot;, &quot;+&quot;] // (1+(4+5+3)-3)+(9+8) var exp = [&quot;(&quot;, &quot;1&quot;, &quot;+&quot;, &quot;(&quot;, &quot;4&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;, &quot;3&quot;, &quot;)&quot;, &quot;-&quot;, &quot;3&quot;, &quot;)&quot;, &quot;+&quot;, &quot;(&quot;, &quot;9&quot;, &quot;+&quot;, &quot;8&quot;, &quot;)&quot;]; console.log(infix_exp_2_postfix_exp(exp)); // 打印结果： [&quot;1&quot;, &quot;4&quot;, &quot;5&quot;, &quot;+&quot;, &quot;3&quot;, &quot;+&quot;, &quot;+&quot;, &quot;3&quot;, &quot;-&quot;, &quot;9&quot;, &quot;8&quot;, &quot;+&quot;, &quot;+&quot;] // (1+(4+5+3)/4-3)+(6+8)*3 var exp = [&apos;(&apos;, &apos;1&apos;, &apos;+&apos;, &apos;(&apos;, &apos;4&apos;, &apos;+&apos;, &apos;5&apos;, &apos;+&apos;, &apos;3&apos;, &apos;)&apos;, &apos;/&apos;, &apos;4&apos;, &apos;-&apos;, &apos;3&apos;, &apos;)&apos;, &apos;+&apos;, &apos;(&apos;, &apos;6&apos;, &apos;+&apos;, &apos;8&apos;, &apos;)&apos;,&apos;*&apos;, &apos;3&apos;]; console.log(infix_exp_2_postfix_exp(exp)); // 打印结果：[&quot;1&quot;, &quot;4&quot;, &quot;5&quot;, &quot;+&quot;, &quot;3&quot;, &quot;+&quot;, &quot;4&quot;, &quot;/&quot;, &quot;+&quot;, &quot;3&quot;, &quot;-&quot;, &quot;6&quot;, &quot;8&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;, &quot;+&quot;] console.log(infix_exp_2_postfix_exp([&quot;12&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;, &quot;5&quot;])); // 打印结果：[&quot;12&quot;, &quot;3&quot;, &quot;5&quot;, &quot;*&quot;, &quot;+&quot;] console.log(infix_exp_2_postfix_exp([&quot;12&quot;, &quot;*&quot;, &quot;3&quot;, &quot;+&quot;, &quot;5&quot;])); // 打印结果：[&quot;12&quot;, &quot;3&quot;, &quot;*&quot;, &quot;5&quot;, &quot;+&quot;]","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://eviler.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://eviler.top/tags/算法/"},{"name":"javascript","slug":"javascript","permalink":"https://eviler.top/tags/javascript/"}]},{"title":"Javascript中的正则表达式详解以及一些常用表单验证实例","date":"2018-11-28T12:06:49.000Z","path":"articles/javascript-regexp/","text":"正则表达式是一个非常好用并且经常会用到的工具，然而学习了好长时间javascript却没有好好地学习一下正则表达式，现在系统地学习一下，并且学以致用，自己写几个用于表单数据格式验证的实例。 什么是正则表达式正则表达式（英语：Regular Expression，再代码证常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。 正则表达式是有一个字符序列形成的搜索模式。 当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。 正则表达式可以是一个简单的字符，或一个更复杂的模式。 正则表达式可用于所有文本搜索和文本替换的操作。 语法var patt = new Reg(pattern, modifiers); 或者更简单的方式： var patt=/pattern/modifiers pattern(模式)描述了表达式的模式 modifiers(修饰符)用于指定全局匹配、区分大小写的匹配和多行匹配注意:当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。比如，以下是等价的： var re = new RegExp(“\\w+”); var re = /\\w+/;RegExp修饰符修饰符用于执行不区分大小写和全文的搜索。 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配 RegExp模式方括号方括号用于查找某个范围的字符： 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [adgk] 查找给定集合内的任何字符。 [^adgk] 查找给定集合外的任何字符。 ( red &#124; blue &#124; green ) 查找任何指定的选项。 元字符元字符（Metacharacter）是拥有特殊含义的字符： 元字符 描述 . 查找单个字符，除了换行和行结束符。 \\w 查找单词字符。 \\W 查找非单词字符。 \\d 查找数字。 \\D 查找非数字字符。 \\s 查找空白字符。 \\S 查找非空白字符。 \\b 匹配单词边界。 \\B 匹配非单词边界。 \\0 查找 NULL 字符。 \\n 查找换行符。 \\f 查找换页符。 \\r 查找回车符。 \\t 查找制表符。 \\v 查找垂直制表符。 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 什么是单词边界？找到一个博客，上面有讲解：正则表达式单词边界和非单词边界 量词 量词 描述 n+ 匹配任何包含至少一个 n 的字符串。 例如，/a+/ 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。 n* 匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。 n? 匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 “angel” 中的 “el”，”angle” 中的 “le”。 n{X} 匹配包含 X 个 n 的序列的字符串。例如，/a{2}/ 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。 n{X,} X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a{2,}/ 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。 n{X,Y} X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。 例如，/a{1,3}/ 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。 n$ 匹配任何结尾为 n 的字符串。 ^n 匹配任何开头为 n 的字符串。 ?=n 匹配任何其后紧接指定字符串 n 的字符串。捕获性分组 ?:n 匹配任何其后紧接指定字符串 n 的字符串。非捕获性分组 ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。 捕获性分组，非捕获性分组，前瞻，后瞻 RegExp 对象方法test方法检索字符串中指定的值。返回 true 或 false。语法：RegExpObject.test(string)参数：string：必须。要检测的字符串。实例： var str=&quot;Hello world!&quot;; //查找&quot;Hello&quot; var patt=/Hello/g; var result=patt.test(str); document.write(&quot;返回值: &quot; + result); //查找 &quot;Runoob&quot; patt=/Runoob/g; result=patt.test(str); document.write(&quot;&lt;br&gt;返回值: &quot; + result); 实例输出结果： 返回值: true 返回值: false exec方法用于检索字符串中的正则表达式的匹配，如果字符串中有匹配的值返回该匹配值，否则返回 null。语法：RegExpObject.exec(string)参数：string：必须。要检测的字符串。实例： var str=&quot;Hello world!&quot;; //查找&quot;Hello&quot; var patt=/Hello/g; var result=patt.exec(str); document.write(&quot;返回值: &quot; + result); //查找 &quot;RUNOOB&quot; patt=/RUNOOB/g; result=patt.exec(str); document.write(&quot;&lt;br&gt;返回值: &quot; + result); 实例输出结果： 返回值: Hello 返回值: false 说明：exec() 方法的功能非常强大，它是一个通用的方法，而且使用起来也比 test() 方法以及支持正则表达式的 String 对象的方法更为复杂。如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。我们可以看得出，在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。比如以下的实例： var str = &quot;Visit W3School&quot;; var patt = new RegExp(&quot;W3School&quot;,&quot;g&quot;); var result; while ((result = patt.exec(str)) != null) { document.write(result); document.write(&quot;&lt;br /&gt;&quot;); document.write(patt.lastIndex); } 输出： W3School 14 compile方法compile() 方法用于在脚本执行过程中编译正则表达式。compile() 方法也可用于改变和重新编译正则表达式。语法：RegExpObject.compile(regexp,modifier)参数：regexp：正则表达式；modifier：规定匹配的类型实例：在字符串中全局搜索 “man”，并用 “person” 替换。然后通过 compile() 方法，改变正则表达式，用 “person” 替换 “man” 或 “woman” var str=&quot;Every man in the world! Every woman on earth!&quot;; patt=/man/g; str2=str.replace(patt,&quot;person&quot;); document.write(str2+&quot;&lt;br /&gt;&quot;); patt=/(wo)?man/g; patt.compile(patt); str2=str.replace(patt,&quot;person&quot;); document.write(str2); 实例输出： Every person in the world! Every woperson on earth! Every person in the world! Every person on earth! toString方法返回正则表达式的字符串值语法：RegExpObject.toString()实例： var patt = new RegExp(&quot;Eviler&quot;, &quot;g&quot;); var res = patt.toString(); document.weite(res); 实例输出： /Eviler/g RegExp 对象属性 属性 描述 global 判断是否设置了 “g” 修饰符 ignoreCase 判断是否设置了 “i” 修饰符 multiline 判断是否设置了 “m” 修饰符 constructor 返回一个函数，该函数是一个创建 RegExp 对象的原型。 lastIndex 用于规定下次匹配的起始位置 source 返回正则表达式的匹配模式 注意： lastIndex 属性只有设置标志 g 才能使用。上次匹配的结果是由方法 RegExp.exec() 和 RegExp.test() 找到的，它们都以 lastIndex 属性所指的位置作为下次检索的起始点。这样，就可以通过反复调用这两个方法来遍历一个字符串中的所有匹配文本。 该属性是可读可写的。只要目标字符串的下一次搜索开始，就可以对它进行设置。当方法 exec() 或 test() 再也找不到可以匹配的文本时，它们会自动把 lastIndex 属性重置为 0。 支持正则表达式的String对象的方法search方法search方法用来检索与正则表达式相匹配的值实例：查找”Eviler”: var str=&quot;Visit Eviler&apos;s Blog!&quot;; var n=str.search(&quot;Eviler&quot;); document.write(n); 实例输出： 6 match方法match方法用来找到一个或多个正则表达式的匹配实例： var str=&quot;The rain in SPAIN stays mainly in the plain&quot;; var n=str.match(/ain/g); document.write(n); 实例输出： ain,ain,ain 注意：match() 方法将检索字符串 String Object，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。 replace方法replace方法用来替换与正则表达式匹配的子串实例： var str=&quot;There are some men and women!Men and Women!&quot;; document.write(&quot;原字符串：&quot;+ &quot;&lt;br /&gt;&quot;+str+ &quot;&lt;br /&gt;&quot;); var m=str.replace(/men/i,&quot;boys&quot;); document.write(&quot;将第一个&apos;men&apos;(不区分大小写)替换成&apos;boys&apos;：&quot;+ &quot;&lt;br /&gt;&quot;+m + &quot;&lt;br /&gt;&quot;); var n=str.replace(/women/gi,&quot;girls&quot;); document.write(&quot;将所有&apos;women&apos;(不区分大小写)替换成&apos;girls&apos;：&quot;+ &quot;&lt;br /&gt;&quot;+n); 实例输出： 原字符串： There are some men and women!Men and Women! 将第一个&apos;men&apos;(不区分大小写)替换成&apos;boys&apos;： There are some boys and women!Men and Women! 将所有&apos;women&apos;(不区分大小写)替换成&apos;girls&apos;： There are some men and girls!Men and girls! split方法split方法用来把字符串分割为字符串数组实例：获取一段英文句子中的单词 var str=&quot;This is my personal page&quot;; document.write(str.split(&apos; &apos;)); 实例输出： This,is,my,personal,page 综合实例&amp;常用表单数据格式验证代码//验证是否位合法的邮箱地址 function isEmail(str) { var reg = /^\\w+@[a-zA-Z0-9]{2,10}(?:\\.[a-z]{2,4}){1,3}$/; return reg.test(str); } //验证是否是合法的手机号码 function isPhoneNumber(str) { var reg = /^1[34578]\\d{9}$/; return reg.test(str); } //验证中国邮政编码,开头不能为0，共6位 function isZipCode(str) { var reg = /^[1-9]\\d{5}$/; return reg.test(str); } //验证中文姓名，2-5个汉字 function isChainName(str) { var reg = /^[\\u4E00-\\u9FA5]{2,5}$/; return reg.test(str); } //验证是否为正整数 function isNumber(str) { if (!str) { return false; } var reg = /\\D/; return !reg.test(str); } 试一试邮&#12288;&#12288;箱：手机号码：邮政编码：中文姓名：正整数验证：验证 function submit() { var input1 = document.getElementById(\"input1\"); var value1 = input1.value; input1.parentNode.querySelector(\".warning\").innerHTML = isEmail(value1) var input2 = document.getElementById(\"input2\"); var value2 = input2.value; input2.parentNode.querySelector(\".warning\").innerHTML = isPhoneNumber(value2) var input3 = document.getElementById(\"input3\"); var value3 = input3.value; input3.parentNode.querySelector(\".warning\").innerHTML = isZipCode(value3) var input4 = document.getElementById(\"input4\"); var value4 = input4.value; input4.parentNode.querySelector(\".warning\").innerHTML = isChainName(value4) var input5 = document.getElementById(\"input5\"); var value5 = input5.value; input5.parentNode.querySelector(\".warning\").innerHTML = isNumber(value5) } //验证是否位合法的邮箱地址 function isEmail(str) { var reg = /^\\w+@[a-zA-Z0-9]{2,10}(?:\\.[a-z]{2,4}){1,3}$/; return reg.test(str); } //验证是否是合法的手机号码 function isPhoneNumber(str) { var reg = /^1[34578]\\d{9}$/; return reg.test(str); } //验证中国邮政编码,开头不能为0，共6位 function isZipCode(str) { var reg = /^[1-9]\\d{5}$/; return reg.test(str); } //验证中文姓名，2-5个汉字 function isChainName(str) { var reg = /^[\\u4E00-\\u9FA5]{2,5}$/; return reg.test(str); } //验证是否为正整数 function isNumber(str) { if (!str) { return false; } var reg = /\\D/; return !reg.test(str); }","tags":[{"name":"javascript","slug":"javascript","permalink":"https://eviler.top/tags/javascript/"}]},{"title":"Html元素类型：块级元素、行内元素（内联元素）和行内块级元素","date":"2018-11-21T14:28:10.000Z","path":"articles/html-element-type/","text":"html中的标签元素大体被分为三种不同的类型：块级元素、内联元素(又叫行内元素)和内联块级元素。事实上，我以前用的时候只是建立在对它们的初步了解之上，可能有时候的使用方法并不正确，这次我需要在实验的基础上去更加深入地认识它们，并且进行一些简单的对比，了解它们之间的差别与联系，从而能够正确地使用它们。 块级元素特点 每个元素都从新的一行开始，其后的元素另起一行，即使设置宽度为0，只要有高度，都会独占一行 元素的高度、宽度、行高以及顶部和内外边距（上下左右）都可设置 元素如果不设置宽度，则是它本身符容器的100%（和父元素的宽度一致） 常见的块状元素div、p、h1~h6、ul、ol、dl、li、dd、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer等 常见的块状元素 内联元素（行内元素）特点 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 常见的内联元素span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block） 常见的内联元素 内联块级元素（行内块级元素）特点(同时具有块级元素、内联元素的特点) 和其他元素都在一行上； 元素的高度、宽度、行高以及内外边距（上下左右）都可设置 常见的内联块状元素input、textarea、select、button 常见的内联块级元素 三种元素类型样式对比代码&lt;hr&gt; &lt;div style=&quot;width:200px;height:100px;background:red&quot;&gt;我是第一个div，宽度200px，高度100px，背景色为红色&lt;/div&gt; &lt;div style=&quot;width:200px;height:100px;background:blue&quot;&gt;我是第二个div，宽度200px，高度100px，背景色为蓝色&lt;/div&gt; &lt;hr&gt; &lt;span style=&quot;width:200px;height:100px;background:red&quot;&gt;我是第一个span，宽度200px，高度100px，背景色为红色&lt;/span&gt; &lt;span style=&quot;width:200px;height:100px;background:blue&quot;&gt;我是第二个span，宽度200px，高度100px，背景色为蓝色&lt;/span&gt; &lt;hr&gt; &lt;button style=&quot;width:200px;height:100px;background:red&quot;&gt;我是第一个button，宽度200px，高度100px，背景色为红色&lt;/button&gt; &lt;button style=&quot;width:200px;height:100px;background:blue&quot;&gt;我是第二个button，宽度200px，高度100px，背景色为蓝色&lt;/button&gt; &lt;hr&gt; 效果我是第一个div，宽度200px，高度100px，背景色为红色我是第二个div，宽度200px，高度100px，背景色为蓝色我是第一个span，宽度200px，高度100px，背景色为红色我是第二个span，宽度200px，高度100px，背景色为蓝色我是第一个button，宽度200px，高度100px，背景色为红色我是第二个button，宽度200px，高度100px，背景色为蓝色 实质上，虽然对span这个内联元素设置了宽度和高度，然而并没有起到效果。 总结三种元素类型的特点决定了它的显示方式和一些属性的可设置性，我们再做网页开发的时候一定要用好它们，有时候如果元素标签本身的类型不能满足我们布局需要的时候，可以使用样式设置对它们进行类型修改变换。 设置display:block；可以将元素转换块级元素； 设置display:inline；可以将块状元素转换为内联元素； 设置display:inline-block；可以将元素设置为内联块级元素。","tags":[{"name":"html","slug":"html","permalink":"https://eviler.top/tags/html/"},{"name":"css","slug":"css","permalink":"https://eviler.top/tags/css/"}]},{"title":"Html中的表格","date":"2018-11-16T07:59:06.000Z","path":"articles/html-table/","text":"Html中的表格是我们经常要用到的，也就是table标签，但是在我们使用table标签的时候是否忽略它本身的一些属性呢？对于我来说是的，所以回头看的同时再记一记笔记，加深印象。 正常表格效果表格标题姓名性别张三男李四男 代码&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 跨行和跨列的表格效果横跨两列的单元格姓名电话张三555 77 556555 77 557李四555 77 558555 77 559 横跨两行的单元格姓名张三电话555 77 556555 77 557 代码&lt;table&gt; &lt;caption&gt;横跨两列的单元格&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;电话&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;555 77 556&lt;/td&gt; &lt;td&gt;555 77 557&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;555 77 558&lt;/td&gt; &lt;td&gt;555 77 559&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table&gt; &lt;caption&gt;横跨两行的单元格&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;td&gt;张三&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;电话&lt;/th&gt; &lt;td&gt;555 77 556&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;555 77 557&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 单元格边距和格间距(Cell padding &amp; Cell spacing)这两个单元格属性我采用对比的方式来说明 效果截图 表格效果截图1 代码&lt;div&gt; &lt;table border=&quot;1&quot;&gt; &lt;caption&gt;无格边距和格间距&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;table cellpadding=&quot;10&quot; border=&quot;1&quot;&gt; &lt;caption&gt;有格边距，无格间距&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;table cellspacing=&quot;15&quot; border=&quot;1&quot;&gt; &lt;caption&gt;无格边距，有格间距&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;table cellpadding=&quot;10&quot; cellspacing=&quot;15&quot; border=&quot;1&quot;&gt; &lt;caption&gt;有格边距和格间距&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; 我想，效果图一做对比很自然地就明白cellpadding和cellspacing的作用以及它们两个的区别了。 框架(frame)属性注释：frame 属性无法在 Internet Explorer 中正确地显示。 效果 表格效果截图2 代码&lt;div&gt; &lt;p&gt;Table with frame=&quot;box&quot;:&lt;/p&gt; &lt;table frame=&quot;box&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;Table with frame=&quot;above&quot;:&lt;/p&gt; &lt;table frame=&quot;above&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;Table with frame=&quot;below&quot;:&lt;/p&gt; &lt;table frame=&quot;below&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;Table with frame=&quot;hsides&quot;:&lt;/p&gt; &lt;table frame=&quot;hsides&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;Table with frame=&quot;vsides&quot;:&lt;/p&gt; &lt;table frame=&quot;vsides&quot;&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; 其他还有一些需要注意的： 空单元格：如果想要一个单元格内容为空但是有边框可以将内容设置为no-breaking空格，即 ‘&amp;’+”nbsp”+’;’ ，你们懂得 向表格/表格单元添加背景颜色或背景图像：使用css添加，和设置普通标签背景色和背景图一样","tags":[{"name":"html","slug":"html","permalink":"https://eviler.top/tags/html/"}]},{"title":"Vscode插件livereload配合chrome扩展程序livereload实现网页自动刷新(保存时)","date":"2018-11-15T14:11:40.000Z","path":"articles/plugin-livereload/","text":"前段时间电脑系统坏了，重新装系统后便是繁琐的软件重装了（对于程序猿来说，开发环境才是大事），这不，重装vscode插件livereload时，竟然忘了它怎么用了！！！？于是有要百度一波，但是，查了好几个博客才解决了我的问题，都怪自己记性不好啦。不多说了，步入正题。 第一步，下载并安装vscode插件livereload在vscode中搜索扩展livereload，选择第一个并点击安装，安装完成后点击重新加载 截图1 第二步，启动livereload server同时按ctrl+shift+p,输入框内输入livereload，就会显示LiveReload:Enable/disable server，点一下就会开启这个服务（再点会关闭，所以如果遇到服务没有开启的问题可以再点一下试试）。 第三步，安装谷歌浏览器插件LiveReload谷歌浏览器网上应用商店搜索（科学上网，自行解决/嘿嘿，也可以百度这个扩展程序，很容易找到的）：LiveReload，安装下图中的扩展程序: 截图2 第四步，打开livereload插件设置，启用扩展程序和允许访问文件网站启用此拓展程序，此程序启用后浏览器右上角会多出一个图标： 截图3 开启允许访问文件网站（只有这样它才能检测到文件的更新）： 截图4 第五步，谷歌浏览器开启此服务在浏览器中打开你想要自动刷新的html文档，点击下图的这个图标：如果中间的小圆圈被填充则说明开启成功 截图5 如果点击一下浏览器弹出下面的弹窗则说明Vscode中的 livereload 服务没开启，回头看一看第二步，重新开一下 截图6 第六步，没有了好了，差不多就这么多了， 用了这个插件，就再也不用在每次查看html编写效果时手动刷新页面了，感觉方便清爽多了，祝大家编程开心。","tags":[{"name":"开发技巧","slug":"开发技巧","permalink":"https://eviler.top/tags/开发技巧/"},{"name":"vscode插件","slug":"vscode插件","permalink":"https://eviler.top/tags/vscode插件/"}]},{"title":"Html中的图像映射","date":"2018-11-14T15:31:46.000Z","path":"articles/html-imgareamap/","text":"当我们需要在一张图片上选择一些区域，这些区域能够被用户所点击然后做出一些动作（如跳转到另一个页面）的时候，图象映射便能够很好地完成这项任务。 需要用到的标签 img : 定义图像 map : 定义图像地图 area : 定义图像地图中的可点击区域 创建步骤 使用 img 标签定义图象 &lt;img src=&quot;./eg_planets.jpg&quot; usemap=&quot;#planemap&quot; alt=&quot;Planets&quot;&gt; 使用map标签定义图像地图 &lt;map name=&quot;planetmap&quot; id=&quot;planetmap&quot;&gt; &lt;/map&gt; 注释：img 元素中的 “usemap” 属性引用 map 元素中的 “id” 或 “name” 属性（根据浏览器），所以同时向 map 元素添加了 “id” 和 “name” 属性。 使用area标签定义图像地图中的可点击区域 &lt;area shape=&quot;circle&quot; coords=&quot;180, 139, 14&quot; href=&quot;&quot; target=&quot;_blank&quot; /&gt; &lt;area shape=&quot;circle&quot; coords=&quot;129, 161, 10&quot; href=&quot;&quot; target=&quot;_blank&quot;/&gt; &lt;area shape=&quot;rect&quot; coords=&quot;0, 0, 110, 260&quot; href=&quot;&quot; target=&quot;_blank&quot;/&gt; 将这些area标签放到map标签内 整体代码&lt;img src=&quot;eg_planets.jpg&quot; usemap=&quot;#planetmap&quot; alt=&quot;Planets&quot;&gt; &lt;map name=&quot;planetmap&quot; id=&quot;planetmap&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;180, 139, 14&quot; href=&quot;&quot; target=&quot;_blank&quot; /&gt; &lt;area shape=&quot;circle&quot; coords=&quot;129, 161, 10&quot; href=&quot;&quot; target=&quot;_blank&quot;/&gt; &lt;area shape=&quot;rect&quot; coords=&quot;0, 0, 110, 260&quot; href=&quot;&quot; target=&quot;_blank&quot;/&gt; &lt;/map&gt; 效果点击图片中的星球可在新的标签页打开本页面，这个可根据自己的需求更改图片来自w3school","tags":[{"name":"html","slug":"html","permalink":"https://eviler.top/tags/html/"}]},{"title":"Html格式化标签","date":"2018-11-13T12:49:11.000Z","path":"articles/html-format/","text":"写了快一年的前端，不知道使以前学校html的时候没有注意还是没有用过就把这个东西忽略了，Html自带一些文本格式化标签，可以满足一些日常简单的文本格式化需求。今天回顾html的时候看到了，学习的同时记一下笔记。 文本格式化效果This text is boldThis text is strongThis text is smallThis text is emphasized（强调）This text is italic（斜体）高亮This text containssubscript(下标)This text containssuperscript(上标) 代码&lt;b&gt;This text is bold&lt;/b&gt; &lt;br /&gt; &lt;strong&gt;This text is strong&lt;/strong&gt; &lt;br /&gt; &lt;small&gt;This text is small&lt;/small&gt; &lt;br /&gt; &lt;em&gt;This text is emphasized（强调）&lt;/em&gt; &lt;br /&gt; &lt;i&gt;This text is italic（斜体）&lt;/i&gt; &lt;br /&gt; &lt;mark&gt;高亮&lt;/mark&gt; &lt;br /&gt; This text contains &lt;sub&gt;subscript(下标)&lt;/sub&gt; &lt;br /&gt; This text contains &lt;sup&gt;superscript(上标)&lt;/sup&gt; &lt;br /&gt; 预格式化文本预格式化文本能够将标签内的文本按照自己原来的文本格式显示出来，它保留了空格和换行。 效果注意：这里编辑器将pre标签自带显示为代码，但效果是一样的 这是 预格式文本。 它保留了 空格 和换行。 for i = 1 to 10 print i next i 代码&lt;pre&gt; 这是 预格式文本。 它保留了 空格 和换行。 &lt;/pre&gt; &lt;pre&gt; for i = 1 to 10 print i next i &lt;/pre&gt; “计算机输出”标签效果Computer codeKeyboard inputSample textComputer variable 代码&lt;code&gt;Computer code&lt;/code&gt; &lt;kbd&gt;Keyboard input&lt;/kbd&gt; &lt;samp&gt;Sample text&lt;/samp&gt; &lt;var&gt;Computer variable&lt;/var&gt; 这些标签常用于显示计算机/编程代码code 元素不保留多余的空格和折行kbd 元素定义键盘输入samp 元素定义计算机输出示例var 元素定义数学变量提示：通常，HTML 使用可变的字母尺寸，以及可变的字母间距。在显示计算机代码示例时，并不需要如此。kbd, samp, 以及 code 元素全都支持固定的字母尺寸和间距。 地址地址标签为address，使用此标签可以在Html文件中写地址 效果Written by Eviler.Visit us at:eviler.top 代码&lt;address&gt;Written by &lt;a href=&quot;eviler.top&quot;&gt;Eviler&lt;/a&gt;. Visit us at: eviler.top &lt;/address&gt; 删除字效果和插入字效果效果一打有 二十 十二 件。 代码&lt;p&gt;一打有 &lt;del&gt;二十&lt;/del&gt; &lt;ins&gt;十二&lt;/ins&gt; 件。&lt;/p&gt; 大多数浏览器会改写为删除文本和下划线文本。一些老式的浏览器会把删除文本和下划线文本显示为普通文本。我们也可以通过改变文本标签的样式来达到这种效果: &lt;p&gt;一打有 &lt;i style=&quot;text-decoration: line-through&quot;&gt;二十&lt;/i&gt; &lt;i style=&quot;text-decoration: underline&quot;&gt;十二&lt;/i&gt; 件。 &lt;/p&gt; 或者使用标签s和u： &lt;p&gt;一打有 &lt;s&gt;二十&lt;/s&gt;&lt;u&gt;十二&lt;/u&gt;件。&lt;/p&gt; 文字方向效果Here is some Hebrew text 如果浏览器支持 bi-directional override (bdo)，下一行会从右向左输出 (rtl):Here is some Hebrew text 代码&lt;bdo&gt; Here is some Hebrew text &lt;/bdo&gt; &lt;p&gt; 如果浏览器支持 bi-directional override (bdo)，下一行会从右向左输出 (rtl):&lt;/p&gt; &lt;bdo dir=&quot;rtl&quot;&gt; Here is some Hebrew text &lt;/bdo&gt; 块引用blockquote和q标签以前倒是注意到过，但是后来也没用过，就把它们给忘了 效果这是长的引用： 这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是短的引用：这是短的引用。 代码这是长的引用： &lt;blockquote&gt; 这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。 &lt;/blockquote&gt; 这是短的引用： &lt;q&gt;这是短的引用。&lt;/q&gt; 使用 blockquote 元素的话，浏览器会插入换行和外边距，而 q 元素不会有任何特殊的呈现。","tags":[{"name":"html","slug":"html","permalink":"https://eviler.top/tags/html/"}]},{"title":"AngularJS踩坑之路(四)：商品展示案例","date":"2018-10-15T11:15:31.000Z","path":"articles/angular-case-commodityShow/","text":"今天跟着老师做了一个简单的商品展示案例，综合使用了前几节课所学到的知识，还有一些前几节课没有涉及到的知识，真是新知复习两不误。 商品展示案例展示页面截图 商品展示案例页面截图 功能简述 显示商品列表 可根据商品名称进行搜索 可按商品评价、价格和销量进行排序展示 商品展示案例代码index.html:&lt;html lang=&quot;en&quot; ng-app=&quot;myApp&quot; id=&quot;ng-app&quot;&gt; &lt;head&gt; &lt;title&gt;商品展示&lt;/title&gt; &lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style media=&quot;screen&quot;&gt; body { padding-top: 50px; } &lt;/style&gt; &lt;/head&gt; &lt;body ng-controller=&quot;itemsController&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6 col-sm-6 col-xs-12&quot;&gt; &lt;div class=&quot;btn-group&quot; role=&quot;group&quot; aria-label=&quot;...&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot; ng-click=&quot;changeOrderKey(&apos;better&apos;)&quot;&gt; 按评价排序 &lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot; ng-click=&quot;changeOrderKey(&apos;price&apos;)&quot;&gt; 按价格排序 &lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot; ng-click=&quot;changeOrderKey(&apos;saled&apos;)&quot;&gt; 按销量排序 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4 col-sm-6 col-xs-12&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;输入商品名称&quot; ng-model=&quot;keyword&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;hr&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-2 col-sm-3 col-xs-4&quot; ng-repeat=&quot;item in items | orderBy:orderByKey:isReverse | filter:results&quot;&gt; &lt;div class=&quot;thumbnall&quot; style=&quot;text-align:center&quot;&gt; &lt;img ng-src=&quot;{{item.img}}&quot; alt=&quot;测试图片&quot;&gt; &lt;div class=&quot;caption&quot;&gt; &lt;h4 ng-bind=&quot;item.name&quot;&gt;&lt;/h4&gt; &lt;h4&gt; &lt;span class=&quot;label label-info&quot;&gt;{{item.price | currency:'￥'}}&lt;/span&gt; &lt;/h4&gt; &lt;h6&gt;已售：{{item.saled}}&lt;/h6&gt; &lt;h6&gt;好评：{{item.better}}&lt;/h6&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.7.0/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/Mock.js/1.0.1-beta3/mock-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; &lt;/html&gt; main.js://使用mock进行ajax拦截及数据生成 Mock.mock(&quot;https://eviler.top/qetItems&quot;, { //url随便写，只要与下面$http.get中用到的url对应就行 &apos;items|10&apos;: [{ &apos;id|+1&apos;: 1, &apos;price&apos;: /[1-9]{4}/, &apos;name&apos;: /(iPhone|sansung|BlackBerry|WindowPhone)[0-9]/, &apos;img&apos;: &quot;@DataImage(120x120, phone)&quot;, &apos;saled&apos;: /[1-9]{4}/, &apos;better&apos;: /[1-9]{4}/ }] }); const app = angular.module(&quot;myApp&quot;, []); //$http服务 专门用来发送ajax请求的服务 Angular内置服务 app.controller(&quot;itemsController&quot;, [&quot;$scope&quot;, &quot;$http&quot;, function($scope, $http) { $scope.items = []; $scope.keyword = &quot;&quot;; $scope.orderByKey = &quot;&quot;; $scope.isReverse = false; $scope.changeOrderKey = function(type) { $scope.orderByKey = type }; $scope.results = function(val) { console.log(val); return val.name.indexOf($scope.keyword) != -1; }; $http.get(&quot;https://eviler.top/qetItems&quot;).then(function(res) { $scope.items = res.data.items; console.log($scope.items); }).catch(function(err) { console.log(err); }) }]) 用到的知识 angularJs的一些内置指令 bootstrap的一些CSS样式 mock.js(模拟后端请求，可以生成随机数据)的简单使用 angularJs的$http服务","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://eviler.top/tags/angularJs/"}]},{"title":"AngularJS踩坑之路(三)：过滤器","date":"2018-10-15T01:19:41.000Z","path":"articles/angular-filter/","text":"过滤器是我们开发过程中经常会用到的东西，实际上，我们在开发中所写的格式化数据的一些函数也可以称之为过滤器，在我以前所用的框架中，过滤器都是自己写的，vue的内置过滤器也只有4种过滤器，一般满足不了我们的需求，但是AngularJS的内置过滤器就不一样了，有9种过滤器，基本可以满足我们日常开发所需，如不满足也没关系，因为我们可以自定义过滤器。 过滤器使用效果预览提示：字符’|’称为管道符 货币格式过滤器：currency 未使用过滤器：4999 使用默认过滤器：$4,999.00 使用自定义传参过滤器：￥4,999.00 时间格式过滤器：date 未使用过滤器：1539570721577 使用默认过滤器：Oct 15, 2018 使用自定义传参过滤器：2018-10-15 Monday, 10:32:01 AM 数字格式过滤器：number 未使用过滤器：1234567890 使用默认过滤器：1,234,567,890 使用自定义传参过滤器：1,234,567,890.00 字母格式过滤器：uppercase &amp; lowercase 原字符串：Hello uppercase过滤器：HELLO lowercase过滤器：hello 数组排序过滤器：orderBy原对象数组（未排序）： Apple—7999 Samsung—4998 Huawei—3999 Meizu—1998排序后（根据price进行排序，并且反向排序，即由大到小排序）： Apple—7999 Samsung—4998 Huawei—3999 Meizu—1998 过滤器：limitTo用于数组(最多显示两项，本来有四项)： Apple—7999 Samsung—4998用于字符串： 原字符串：Hello 取前三个字符：Hel 取后三个字符：llo 过滤器：filterfilter根据传入的参数从给定的数组中选择一个子集，并生成一个新数组返回原数据： Apple—7999 Samsung—4998 Meizu—1998 Huawei—3999过滤后(过滤含有字符’i’的项))： Meizu—1998 Huawei—3999注意：此过滤方式不区分字段，即只要单个项中存在所匹配内容（’i’），这个phone就会被匹配 格式化json对象过滤器：json这个就和我们熟悉的JSON.stringify()作用一样 用法：{ { jsonTest | json } }(去掉两个大括号之间的空格) 自定义过滤器上面所讲的几种过滤器都是angular内置的过滤器，提供给的功能有时候只能解决我们的部分需求，这时候就需要我们来使用自定义过滤器了。 原字符串：Hello 使用自定义过滤器myFilter（将字符串字符转化为大写）：HELLO 原数组：[1,2,3,4,5] 使用自定义过滤器arrFilter（每一项值的下标次幂，Math.pow(arr[index],index)）：[1,2,9,64,625] 注意：自定义过滤器必须有返回值 最后再说一下，这些过滤器是可以连用的，怎样使用？用管道符连接即可。 代码为了方便书写，我直接把上面输出结果的代码都写在了这里： &lt;html ng-app=&quot;myApp&quot; id=&quot;ng-app&quot;&gt; &lt;head&gt; &lt;title&gt;Angular&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.3.0-beta.7/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller=&quot;myController&quot;&gt; &lt;em&gt;提示：字符&apos;|&apos;称为管道符&lt;/em&gt; &lt;h4&gt;货币格式过滤器：currency&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;未使用过滤器：{{price}}&lt;/li&gt; &lt;li&gt;使用默认过滤器：{{price | currency}}&lt;/li&gt; &lt;li&gt;使用自定义传参过滤器：{{price | currency:'￥'}}&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;时间格式过滤器：date&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;未使用过滤器：{{time}}&lt;/li&gt; &lt;li&gt;使用默认过滤器：{{time | date}}&lt;/li&gt; &lt;li&gt;使用自定义传参过滤器：{{time | date:'yyyy-MM-dd EEEE, hh:mm:ss a'}}&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;数字格式过滤器：number &lt;/h4&gt; &lt;ul&gt; &lt;li&gt;未使用过滤器：{{count}}&lt;/li&gt; &lt;li&gt;使用默认过滤器：{{count | number}}&lt;/li&gt; &lt;li&gt;使用自定义传参过滤器：{{count | number:2}}&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;字母格式过滤器：uppercase &amp; lowercase&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;原字符串：{{'Hello'}}&lt;/li&gt; &lt;li&gt;uppercase过滤器：{{'Hello' | uppercase}}&lt;/li&gt; &lt;li&gt;lowercase过滤器：{{'Hello' | lowercase}}&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;数组排序过滤器：orderBy&lt;/h4&gt; &lt;div&gt; &lt;h5&gt;原对象数组（未排序）：&lt;/h5&gt; &lt;ul&gt; &lt;li &gt; {{phone.name}}---{{phone.price}} &lt;/li&gt; &lt;/ul&gt; &lt;h5&gt;排序后（根据price进行排序，并且反向排序，即由大到小排序）：&lt;/h5&gt; &lt;ul&gt; &lt;li &gt; {{phone.name}}---{{phone.price}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h4&gt;过滤器：limitTo&lt;/h4&gt; &lt;div&gt; &lt;h5&gt;用于数组(最多显示两项，本来有四项)：&lt;/h5&gt; &lt;ul&gt; &lt;li &gt; {{phone.name}}---{{phone.price}} &lt;/li&gt; &lt;/ul&gt; &lt;h5&gt;用于字符串：&lt;/h5&gt; &lt;ul&gt; &lt;li&gt;原字符串：Hello&lt;/li&gt; &lt;li&gt;取前三个字符：{{\"Hello\" | limitTo:3}}&lt;/li&gt; &lt;li&gt;取后三个字符：{{\"Hello\" | limitTo:-3}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h4&gt;过滤器：filter&lt;/h4&gt; &lt;div&gt; &lt;p&gt;filter根据传入的参数从给定的数组中选择一个子集，并生成一个新数组返回&lt;/p&gt; &lt;h5&gt;原数据：&lt;/h5&gt; &lt;ul&gt; &lt;li &gt; {{phone.name}}---{{phone.price}} &lt;/li&gt; &lt;/ul&gt; &lt;h5&gt;过滤后(过滤含有字符&apos;i&apos;的项))：&lt;/h5&gt; &lt;ul&gt; &lt;li &gt; {{phone.name}}---{{phone.price}} &lt;/li&gt; &lt;/ul&gt; &lt;em&gt;注意：此过滤方式不区分字段，即只要单个项中存在所匹配内容（&apos;i&apos;），这个phone就会被匹配&lt;/em&gt; &lt;/div&gt; &lt;h4&gt;格式化json对象过滤器：json&lt;/h4&gt; &lt;div&gt; &lt;p&gt;这个就和我们熟悉的JSON.stringify()作用一样&lt;br&gt; 用法：{ { jsonTest | json } }(去掉两个大括号之间的空格) &lt;/p&gt; &lt;/div&gt; &lt;h4&gt;自定义过滤器&lt;/h4&gt; &lt;div&gt; &lt;p&gt;上面所讲的几种过滤器都是angular内置的过滤器，提供给的功能有时候只能解决我们的部分需求，这时候就需要我们来使用自定义过滤器了。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;原字符串：Hello 使用自定义过滤器myFilter（将字符串字符转化为大写）：{{\"Hello\" | myFilter}} &lt;/li&gt; &lt;li&gt;原数组：{{arr}} 使用自定义过滤器arrFilter（每一项值的下标次幂，Math.pow(arr[index],index)）：{{arr | arrFilter}} &lt;/li&gt; &lt;/ul&gt; &lt;em&gt;注意：自定义过滤器必须有返回值&lt;/em&gt; &lt;/div&gt; &lt;p&gt;最后再说一下，这些过滤器是可以连用的，怎样使用？用管道符连接即可。&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); app.run([&quot;$rootScope&quot;, function($rootScope) {}]); app.controller(&quot;myController&quot;, [&quot;$scope&quot;, function($scope) { $scope.orderKey = &quot;price&quot;; $scope.isOrderReverse = true; $scope.filterKey = &apos;i&apos;; $scope.price = 4999; $scope.time = Date.now(); $scope.count = 1234567890; $scope.phones = [{ name: &quot;Apple&quot;, price: 7999 }, { name: &quot;Samsung&quot;, price: 4998 }, { name: &quot;Meizu&quot;, price: 1998 }, { name: &quot;Huawei&quot;, price: 3999 }]; $scope.arr = [1, 2, 3, 4, 5]; }]); app.filter(&quot;myFilter&quot;, function() { return function(val) { return val.toUpperCase() } }) app.filter(&quot;arrFilter&quot;, function() { return function(val) { return val.map(Math.pow); } }) &lt;/script&gt; &lt;/html&gt;","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://eviler.top/tags/angularJs/"}]},{"title":"AngularJS踩坑之路(二)：控制器","date":"2018-10-14T06:50:09.000Z","path":"articles/angular-controller/","text":"今天学习了一下AngularJS中的控制器，所以这篇主要记录一下AngularJS控制器中的一些知识 概念AngularJS中的控制器是一个函数，用来向视图的作用域中添加额外的功能，我们用它来给作用于对象设置初始状态，并添加自定义行为当我们在页面上创建一个新的控制器时，AngularJS会生产并传递一个新的$scope给这个控制器，可以在这个控制器力初始化$scope。 使用控制器 创建控制器 //创建一个模块，并将控制器声明到改模块上，以避免全局污染 var app = angular.module(&quot;myApp&quot;, []); //使用module实例的controller方法创建控制器，并且将创建控制器生产的$scope注入进来，注入方式有两种，可任选其一 app.controller(&quot;myController&quot;, [&quot;$scope&quot;, function($scope) { $scope.name = &quot;Eviler&quot;; $scope.testFunc = function(){ return &quot;Hello&quot;; } }]); 在html中使用 &lt;!--由于创建了自己的模块，在这里要是有ng-app指定自己的模块--&gt; &lt;html ng-app=&quot;myApp&quot; id=&quot;ng-app&quot;&gt; &lt;!--body中--&gt; &lt;div ng-controller=&quot;myController&quot;&gt;&lt;!--通过ng-controller指令将创建的控制器绑定在元素上--&gt; {{testFunc()}} {{name}}&lt;!--输出testFunc方法和name值--&gt; &lt;/div&gt; 注入形式常见的有两种： app.controller(&quot;myController&quot;, [&quot;$scope&quot;, function($scope) { //内联式注入，推荐 $scope.name = &quot;Eviler&quot;; $scope.testFunc = function(){ return &quot;Hello&quot;; } }]); app.controller(&quot;myController&quot;, function($scope) { //推断式注入 //代码不能进行压缩混淆 $scope.name = &quot;Eviler&quot;; $scope.testFunc = function(){ return &quot;Hello&quot;; } }); 控制器可以将与一个独立试图相关的业务逻辑封装在一个独立的容器中。尽可能地精简控制器时很好的做法控制器并不适合用来执行DOM操作、格式化或数据操作，以及除存储数据模型之外的状态维护操作，它只是试图和$scope之间的桥梁 $scope和$rootScopeAngularJS应用程序含有嵌套作用域，这种嵌套结构和DOM的嵌套结构极为类似；而这种嵌套作用域的顶级作用域便是$rootScope，也就是ng-app指令所在的位置；在AngularJS中，除了隔离作用域外，其他所有的作用于都通过原型继承而来，也就是说他们都可以访问父级作用域。请看以下代码：html: &lt;div ng-controller=&quot;myController&quot;&gt; &lt;hr&gt; {{testFun()}} {{name}} {{age}} {{address}} &lt;h4&gt;子级的address值：{{address}}&lt;/h4&gt; &lt;hr&gt; &lt;div ng-controller=&quot;childController&quot;&gt; {{name}} {{age}} {{address}} &lt;/div&gt; &lt;hr&gt; &lt;div ng-controller=&quot;childController2&quot;&gt; {{name}} {{age}} {{zipCode}} &lt;h4&gt;同级的address值：{{address}}&lt;/h4&gt; &lt;/div&gt; &lt;hr&gt; &lt;/div&gt; javascript: var app = angular.module(&quot;myApp&quot;, []); //创建一个模块 app.run([&quot;$rootScope&quot;, function($rootScope) { $rootScope.name = &quot;Eviler&quot;; $rootScope.testFun = function() { return &quot;hello&quot; } }]); //myController app.controller(&quot;myController&quot;, [&quot;$scope&quot;, function($scope) { $scope.age = 20; }]); //childController app.controller(&quot;childController&quot;, [&quot;$scope&quot;, function($scope) { $scope.address = &quot;BeiJing&quot; }]) //childController2 app.controller(&quot;childController2&quot;, [&quot;$scope&quot;, function($scope) { $scope.zipCode = &quot;1234567&quot; }]) 然后看一下代码的运行结果： hello Eviler 20子级的address值： Eviler 20 Beijing Eviler 20 123456同级的address值： 我们来分析一下：name属性和testFunc方法来自$rootScopeage属性来自myController的$scopeaddress属性来自childController的$scopezipCode属性来自childController2的$scope 在myController作用域中：name、testFunc、age都能被正常访问，而访问不到定义于childController中address属性在childController2作用域中：name、testFunc、zipCode都能被正常访问，而访问不到定义于同级的childController2中的address属性所以说：父级不能使用子级的值，同级的控制器之间也不能相互使用不属于自己的值","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://eviler.top/tags/angularJs/"}]},{"title":"AngularJS踩坑之路(一)：一些有关内置指令的要记","date":"2018-10-13T12:45:10.000Z","path":"articles/angular-directive/","text":"开始入坑angularJs，在此记录一下自己学习过程中的点滴，希望angular大哥能够友好对待小弟，我的学习地址：网易云云课堂，本文章记录一些我觉得需要记录的知识点和注意事项。 表达式注意事项 不能使用任何流程控制语句(if/else) 可以使用过滤器或过滤器链（虽然还不知道怎么使用emmmm） ng-switch指令&lt;div&gt; &lt;select ng-model=&quot;selectItem&quot;&gt; &lt;option value=&quot;java&quot;&gt;java&lt;/option&gt; &lt;option value=&quot;php&quot;&gt;php&lt;/option&gt; &lt;/select&gt; &lt;ul ng-switch=&quot;selectItem&quot;&gt; &lt;li ng-switch-when=&quot;java&quot;&gt;选择了Java&lt;/li&gt; &lt;li ng-switch-when=&quot;php&quot;&gt;选择了Php&lt;/li&gt; &lt;li ng-switch-default&gt;什么都没选&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ng-repeat指令&lt;div ng-init=&quot;arr=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&quot;&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;x in arr&quot;&gt;{{x}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 注意：下面的使用方法会使angular抛出异常 &lt;div ng-init=&quot;arr2=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;b&apos;]&quot;&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;m in arr2&quot;&gt;{{m}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 我们注意到，上面的arr2中有两个相同的字符’b’,angular再便利时需要一个唯一值可以与生成的dom绑定，以便追踪，而在指定的组中出现了相同的值’b’，此时需要track by来为angular确定一个唯一值，将上面的代码改为如下即可： &lt;div ng-init=&quot;arr2=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;b&apos;]&quot;&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;m in arr2 track by $index&quot;&gt;{{m}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 我在想，如果为了避免这种错误再次发生，我们是否可以每次使用ng-repeat指令都使用track by $index呢？我觉得没问题=_=使用过vue的人就会发现，我们使用v-for时，一般都是这种格式: &lt;li v-for=&quot;(item, index) in itenList&quot; :key=&quot;index&quot;&gt;&lt;/li&gt; 我在使用过程中发现，如果不绑定key，编辑器会发出警告信息（可能是vscode插件起的作用吧，不做追究了）angular的ng-repeat何尝不这样做呢，有利无害有木有（按照我的经验和我现在的学习进度来看）。注意：上面的话我得回收一下，因为学完这个的第二天，我又学习了过滤器，然后才发现用过滤器的时候不能使用track by，哈哈哈，打脸啪-啪-啪，左右左右BABA 还有需要注意的地方就是有关’$’操作符，按照我的理解：$index 返回数组下标$first 返回布尔值：是否为数组第一项$last 返回布尔值：是否为数组最后项 ng-class指令看看下面的代码： &lt;div ng-init=&quot;c1=&apos;box1&apos;;bol=true;isC1=true;isC2=true;isC3=false&quot;&gt; &lt;div class=&quot;box&quot; ng-class=&quot;c1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot; ng-class=&quot;{true:&apos;box2&apos;,false:&apos;box3&apos;}[bol]&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot; ng-class=&quot;{&apos;box1&apos;:isC1,&apos;box2&apos;:isC2,&apos;box3&apos;:isC3}&quot;&gt;&lt;/div&gt; &lt;/div&gt; 其中box、box1、box2、box3为样式类名这段代码的效果是：里层的三个div绑定的class分别为（box1）、（box2）和（box1、box2）,这是dom绑定class的三种方式，我们注意到，第一种绑定方式先把类名box1赋值给c1，然后再把c1绑定在指令ng-class，这样是不是显得麻烦了？为何不直接使用下面的代码进行绑定呢： &lt;div class=&quot;box&quot; ng-class=&quot;box1&quot;&gt;&lt;/div&gt; 我试了一下，这样绑定是没有效果的，也就是没有绑定成功，但如果像下面这样使用，就可以绑定成功（box外面加一层单引号）： &lt;div class=&quot;box&quot; ng-class=&quot;&apos;box1&apos;&quot;&gt;&lt;/div&gt;","tags":[{"name":"angularJs","slug":"angularJs","permalink":"https://eviler.top/tags/angularJs/"}]}]